{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sistemas Hardware-Software \u00b6 Bem vindo ao curso de Sistemas Hardware-Software 2023/2. Professor : Carlos Eduardo Dantas de Menezes ( carlosedm@insper.edu.br ) Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamento: Avalia\u00e7\u00f5es Intermedi\u00e1ria (AI) e Final (AF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site Ver crit\u00e9rios de avalia\u00e7\u00e3o na aula 01","title":"Home"},{"location":"#sistemas-hardware-software","text":"Bem vindo ao curso de Sistemas Hardware-Software 2023/2. Professor : Carlos Eduardo Dantas de Menezes ( carlosedm@insper.edu.br )","title":"Sistemas Hardware-Software"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamento: Avalia\u00e7\u00f5es Intermedi\u00e1ria (AI) e Final (AF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site Ver crit\u00e9rios de avalia\u00e7\u00e3o na aula 01","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Aulas \u00b6 QUA 15:45 - 17:45 (Sala 513) SEX 15:45 - 17:45 (Sala 513) Atendimento: SEX 14:15 - 15:45 (Sala 513) Entregas de Atividades e Labs \u00b6 Data in\u00edcio Atividade/Lab Como entregar Prazo 11/08 Instala\u00e7\u00e3o Sem entrega, apenas instale o Ubuntu 22.04! 23/08 25/08 01-inteiros Github (Lembre de Criar repo e Configurar webhook ) 29/08 23h59 30/08 02-intro-gdb Github 03/09 23h59 01/09 03-funcoes Github 10/09 23h59 06/09 01-hackerlab Github 01/10 23h59 Provas \u00b6 Labs de C : final da primeira semana AI : https://www.insper.edu.br/portaldoprofessor/ciencia-da-computacao/ AF : https://www.insper.edu.br/portaldoprofessor/ciencia-da-computacao/ SUB : https://www.insper.edu.br/portaldoprofessor/ciencia-da-computacao/ Delta : no dia e hor\u00e1rio da SUB","title":"Entregas e Prazos"},{"location":"sobre/#aulas","text":"QUA 15:45 - 17:45 (Sala 513) SEX 15:45 - 17:45 (Sala 513) Atendimento: SEX 14:15 - 15:45 (Sala 513)","title":"Aulas"},{"location":"sobre/#entregas-de-atividades-e-labs","text":"Data in\u00edcio Atividade/Lab Como entregar Prazo 11/08 Instala\u00e7\u00e3o Sem entrega, apenas instale o Ubuntu 22.04! 23/08 25/08 01-inteiros Github (Lembre de Criar repo e Configurar webhook ) 29/08 23h59 30/08 02-intro-gdb Github 03/09 23h59 01/09 03-funcoes Github 10/09 23h59 06/09 01-hackerlab Github 01/10 23h59","title":"Entregas de Atividades e Labs"},{"location":"sobre/#provas","text":"Labs de C : final da primeira semana AI : https://www.insper.edu.br/portaldoprofessor/ciencia-da-computacao/ AF : https://www.insper.edu.br/portaldoprofessor/ciencia-da-computacao/ SUB : https://www.insper.edu.br/portaldoprofessor/ciencia-da-computacao/ Delta : no dia e hor\u00e1rio da SUB","title":"Provas"},{"location":"aulas/01-inteiros/","text":"01 - Inteiros na CPU \u00b6 Os exerc\u00edcios da aula de hoje est\u00e3o no execut\u00e1vel bases_e_sinais . Aula com atividade para entrega! Confira em Conte\u00fados no Blackboard como criar seu reposit\u00f3rio para entregas e configurar o webhook do servidor de testes. Assim que criar seu reposit\u00f3rio, a atividade 01 j\u00e1 estar\u00e1 dispon\u00edvel nele. Configure o webhook para conseguir realizar as entregas. Atividade 01: atv01 \u00b6 Tip Leia o README dispon\u00edvel na pasta atv\\01-inteiros do seu reposit\u00f3rio de entregas! Nesta atividade, \u00e9 esperado que voc\u00ea realize diversas convers\u00f5es entre bases. O que voc\u00ea precisa fazer \u00e9: 1. Rodar programa bases_e_sinais 2. Colocar sua solu\u00e7\u00e3o em solucao.txt 3. Verificar se tudo est\u00e1 ok rodando (a saida final do programa \u00e9 Exerc\u00edcio correto! ) Ent\u00e3o, quando o execut\u00e1vel bases_e_sinais for chamado com ./bases_e_sinais < solucao.txt o esperado \u00e9 que seja obitido na sa\u00edda o texto Exerc\u00edcio correto! . Assim, tudo est\u00e1 Ok e voc\u00ea pode fazer o release! Boa atividade! Tip O README dispon\u00edvel na pasta atv\\01-inteiros tamb\u00e9m indica como realizar a entrega !","title":"01 - Inteiros na CPU"},{"location":"aulas/01-inteiros/#01-inteiros-na-cpu","text":"Os exerc\u00edcios da aula de hoje est\u00e3o no execut\u00e1vel bases_e_sinais . Aula com atividade para entrega! Confira em Conte\u00fados no Blackboard como criar seu reposit\u00f3rio para entregas e configurar o webhook do servidor de testes. Assim que criar seu reposit\u00f3rio, a atividade 01 j\u00e1 estar\u00e1 dispon\u00edvel nele. Configure o webhook para conseguir realizar as entregas.","title":"01 - Inteiros na CPU"},{"location":"aulas/01-inteiros/#atividade-01-atv01","text":"Tip Leia o README dispon\u00edvel na pasta atv\\01-inteiros do seu reposit\u00f3rio de entregas! Nesta atividade, \u00e9 esperado que voc\u00ea realize diversas convers\u00f5es entre bases. O que voc\u00ea precisa fazer \u00e9: 1. Rodar programa bases_e_sinais 2. Colocar sua solu\u00e7\u00e3o em solucao.txt 3. Verificar se tudo est\u00e1 ok rodando (a saida final do programa \u00e9 Exerc\u00edcio correto! ) Ent\u00e3o, quando o execut\u00e1vel bases_e_sinais for chamado com ./bases_e_sinais < solucao.txt o esperado \u00e9 que seja obitido na sa\u00edda o texto Exerc\u00edcio correto! . Assim, tudo est\u00e1 Ok e voc\u00ea pode fazer o release! Boa atividade! Tip O README dispon\u00edvel na pasta atv\\01-inteiros tamb\u00e9m indica como realizar a entrega !","title":"Atividade 01: atv01"},{"location":"aulas/02-ram/","text":"02 - Representa\u00e7\u00e3o de dados em RAM \u00b6 Experimentos \u00b6 Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles, execute e analise suas sa\u00eddas. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Tente entender o que est\u00e1 acontecendo. Para compilar cada .c , utilize: $ gcc -Wall -pedantic experimento0.c -o e0 Exercise Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Representa\u00e7\u00e3o de struct em RAM \u00b6 A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Aten\u00e7\u00e3o! Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Vamos compilar?! Compile e execute parte1.c . Exercise Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Exercise A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Exercise Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C . Hora de conferir! Agora confira suas respostas no arquivo parte1.c . Examinando a execu\u00e7\u00e3o de programas usando gdb \u00b6 Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Dica! Para compilar um programa com suporte a debugging usamos a flag -g do gcc $ gcc -g -Wall -pedantic parte2.c -o parte2 Siga os passos para para carregar um programa usando o gdb : Lance o gdb e passe para ele seu programa: $ gdb ./parte2 Para sair, utilize: (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser vista em https://sourceware.org/gdb/onlinedocs/gdb/index.html#Top . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Exercise Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Aten\u00e7\u00e3o, tarefa dupla! Para os pr\u00f3ximos exerc\u00edcios, compile o arquivo parte2.c com e sem debugging e repita cada exerc\u00edcio com ambas as vers\u00f5es do execut\u00e1vel. Exemplo de compila\u00e7\u00e3o: $ gcc -g -Wall -pedantic parte2.c -o parte2_debug $ gcc -Wall -pedantic parte2.c -o parte2_semdebug Exercise O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Execute-o e veja o que acontece. Exercise Use info para mostrar as fun\u00e7\u00f5es e vari\u00e1veis globais que existem em parte2 . Lembre de fazer tanto na vers\u00e3o com quanto na sem debugging ! Muita informa\u00e7\u00e3o! Muitos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Exercise Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Exercise Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Mostre o valor inicial de global_var usando este comando e compare com o visto no arquivo parte2.c . Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos de C ( casting ) pode ser \u00fatil aqui. Exercise Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o , entenda como usar o comando x e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Em seguida, teste-o e garanta que funcionou corretamente. Link: https://sourceware.org/gdb/onlinedocs/gdb/Memory.html Dicas : volte nos exerc\u00edcios anteriores e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Exercise global_array tem tipo short . Ou seja, \u00e9 formado por dois bytes. Mostre agora o conte\u00fado de cada um deles. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Exercise Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"02 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/02-ram/#02-representacao-de-dados-em-ram","text":"","title":"02 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/02-ram/#experimentos","text":"Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles, execute e analise suas sa\u00eddas. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Tente entender o que est\u00e1 acontecendo. Para compilar cada .c , utilize: $ gcc -Wall -pedantic experimento0.c -o e0 Exercise Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Exercise Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa.","title":"Experimentos"},{"location":"aulas/02-ram/#representacao-de-struct-em-ram","text":"A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Aten\u00e7\u00e3o! Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Vamos compilar?! Compile e execute parte1.c . Exercise Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Exercise A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Exercise Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C . Hora de conferir! Agora confira suas respostas no arquivo parte1.c .","title":"Representa\u00e7\u00e3o de struct em RAM"},{"location":"aulas/02-ram/#examinando-a-execucao-de-programas-usando-gdb","text":"Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Dica! Para compilar um programa com suporte a debugging usamos a flag -g do gcc $ gcc -g -Wall -pedantic parte2.c -o parte2 Siga os passos para para carregar um programa usando o gdb : Lance o gdb e passe para ele seu programa: $ gdb ./parte2 Para sair, utilize: (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser vista em https://sourceware.org/gdb/onlinedocs/gdb/index.html#Top . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Exercise Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Aten\u00e7\u00e3o, tarefa dupla! Para os pr\u00f3ximos exerc\u00edcios, compile o arquivo parte2.c com e sem debugging e repita cada exerc\u00edcio com ambas as vers\u00f5es do execut\u00e1vel. Exemplo de compila\u00e7\u00e3o: $ gcc -g -Wall -pedantic parte2.c -o parte2_debug $ gcc -Wall -pedantic parte2.c -o parte2_semdebug Exercise O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Execute-o e veja o que acontece. Exercise Use info para mostrar as fun\u00e7\u00f5es e vari\u00e1veis globais que existem em parte2 . Lembre de fazer tanto na vers\u00e3o com quanto na sem debugging ! Muita informa\u00e7\u00e3o! Muitos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Exercise Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Exercise Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Mostre o valor inicial de global_var usando este comando e compare com o visto no arquivo parte2.c . Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos de C ( casting ) pode ser \u00fatil aqui. Exercise Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o , entenda como usar o comando x e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Em seguida, teste-o e garanta que funcionou corretamente. Link: https://sourceware.org/gdb/onlinedocs/gdb/Memory.html Dicas : volte nos exerc\u00edcios anteriores e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Exercise global_array tem tipo short . Ou seja, \u00e9 formado por dois bytes. Mostre agora o conte\u00fado de cada um deles. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Exercise Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"Examinando a execu\u00e7\u00e3o de programas usando gdb"},{"location":"aulas/03-arquitetura-x86/","text":"03 - Arquitetura x86-64 \u00b6 No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o . Parando e continuando a execu\u00e7\u00e3o de um programa. \u00b6 Compile funcoes.c usando as flags: $ gcc -Og -g -Wall -std = c99 funcoes.c -o funcoes Tip Na compila\u00e7\u00e3o, -Og ir\u00e1 permitir otimiza\u00e7\u00f5es de c\u00f3digo que n\u00e3o interfiram no debugging. J\u00e1 o par\u00e2metro -g ir\u00e1 tornar dispon\u00edveis informa\u00e7\u00f5es \u00fateis para o debugging (como tipos de vari\u00e1veis e cabe\u00e7alhos das fun\u00e7\u00f5es) Exercise Abra o execut\u00e1vel com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Exercise O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Exercise Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Exercise Use o comando break funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Ap\u00f3s executar o run , utilize disas funcao1 e observe no c\u00f3digo da fun\u00e7\u00e3o uma seta indicando o pr\u00f3ximo comando a ser executado, que representa o breakpoint no in\u00edcio da fun\u00e7\u00e3o. Dica Os comandos info breakpoints , info b ou ainda i b podem ser utilizados para listar os breakpoints inseridos no c\u00f3digo! Exercise Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta do Exerc\u00edcio 2 e escreva abaixo suas novas conclus\u00f5es. Exercise O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Dicas : se a primeira instru\u00e7\u00e3o for endbr64 , execute stepi mais uma vez! use disas de novo verifique novamente o conte\u00fado de %edi Exercise Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Exercise Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? Exercise Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Exercise Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado no endere\u00e7o descoberto no exerc\u00edcio anterior. Confira seu resultado com o c\u00f3digo. Tip Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine. Endere\u00e7amento relativo e vari\u00e1veis globais \u00b6 Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Exercise Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Exercise Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Exercise Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Exercise Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Exercise Anote abaixo o endere\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Desenho de acesso a mem\u00f3ria usando %rip A figura abaixo ilustra como funciona o endere\u00e7amento usando o registrador %rip . Note que os deslocamentos s\u00e3o diferentes pois o endere\u00e7o da instru\u00e7\u00e3o atual \u00e9 diferente. Por\u00e9m, o resultado final do endere\u00e7o calculado em ambas instru\u00e7\u00f5es \u00e9 o mesmo, indicando que ambas se referem ao mesmo local na mem\u00f3ria. Exercise Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Exercise Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Exercise Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf , analise as chamadas para responder o pr\u00f3ximo exerc\u00edcio! Exercise Encontre os endere\u00e7o das strings de formata\u00e7\u00e3o do printf e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo. Atividade para entrega! \u00b6 Aula com atividade para entrega . Confira seu reposit\u00f3rio de entregas do classroom! Aten\u00e7\u00e3o Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de atv . Dica Leia o README.md dispon\u00edvel na pasta da atividade para descobrir como resolver e entregar.","title":"03 - Arquitetura x86-64"},{"location":"aulas/03-arquitetura-x86/#03-arquitetura-x86-64","text":"No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o .","title":"03 - Arquitetura x86-64"},{"location":"aulas/03-arquitetura-x86/#parando-e-continuando-a-execucao-de-um-programa","text":"Compile funcoes.c usando as flags: $ gcc -Og -g -Wall -std = c99 funcoes.c -o funcoes Tip Na compila\u00e7\u00e3o, -Og ir\u00e1 permitir otimiza\u00e7\u00f5es de c\u00f3digo que n\u00e3o interfiram no debugging. J\u00e1 o par\u00e2metro -g ir\u00e1 tornar dispon\u00edveis informa\u00e7\u00f5es \u00fateis para o debugging (como tipos de vari\u00e1veis e cabe\u00e7alhos das fun\u00e7\u00f5es) Exercise Abra o execut\u00e1vel com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Exercise O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Exercise Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Exercise Use o comando break funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Ap\u00f3s executar o run , utilize disas funcao1 e observe no c\u00f3digo da fun\u00e7\u00e3o uma seta indicando o pr\u00f3ximo comando a ser executado, que representa o breakpoint no in\u00edcio da fun\u00e7\u00e3o. Dica Os comandos info breakpoints , info b ou ainda i b podem ser utilizados para listar os breakpoints inseridos no c\u00f3digo! Exercise Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta do Exerc\u00edcio 2 e escreva abaixo suas novas conclus\u00f5es. Exercise O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Dicas : se a primeira instru\u00e7\u00e3o for endbr64 , execute stepi mais uma vez! use disas de novo verifique novamente o conte\u00fado de %edi Exercise Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Exercise Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? Exercise Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Exercise Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado no endere\u00e7o descoberto no exerc\u00edcio anterior. Confira seu resultado com o c\u00f3digo. Tip Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine.","title":"Parando e continuando a execu\u00e7\u00e3o de um programa."},{"location":"aulas/03-arquitetura-x86/#enderecamento-relativo-e-variaveis-globais","text":"Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Exercise Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Exercise Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Exercise Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Exercise Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Exercise Anote abaixo o endere\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Desenho de acesso a mem\u00f3ria usando %rip A figura abaixo ilustra como funciona o endere\u00e7amento usando o registrador %rip . Note que os deslocamentos s\u00e3o diferentes pois o endere\u00e7o da instru\u00e7\u00e3o atual \u00e9 diferente. Por\u00e9m, o resultado final do endere\u00e7o calculado em ambas instru\u00e7\u00f5es \u00e9 o mesmo, indicando que ambas se referem ao mesmo local na mem\u00f3ria. Exercise Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Exercise Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Exercise Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf , analise as chamadas para responder o pr\u00f3ximo exerc\u00edcio! Exercise Encontre os endere\u00e7o das strings de formata\u00e7\u00e3o do printf e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo.","title":"Endere\u00e7amento relativo e vari\u00e1veis globais"},{"location":"aulas/03-arquitetura-x86/#atividade-para-entrega","text":"Aula com atividade para entrega . Confira seu reposit\u00f3rio de entregas do classroom! Aten\u00e7\u00e3o Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de atv . Dica Leia o README.md dispon\u00edvel na pasta da atividade para descobrir como resolver e entregar.","title":"Atividade para entrega!"},{"location":"aulas/04-funcoes-mov/","text":"04 - Fun\u00e7\u00f5es \u00b6 Neste handout vamos trabalhar pela primeira vez na tradu\u00e7\u00e3o reversa de programas em Assembly para C . Nas \u00faltimas aulas vimos as instru\u00e7\u00f5es mov e add e na aula de hoje vimos uma tabela grande com as instru\u00e7\u00f5es aritm\u00e9ticas ( add , sub , mul , imul , div , etc). Como em todas as aulas, veremos hoje um detalhe a mais sobre arquitetura x64 : chamadas de fun\u00e7\u00f5es e argumentos. Fun\u00e7\u00f5es e seus argumentos \u00b6 Em x64 os argumentos das fun\u00e7\u00f5es s\u00e3o passados nos registradores e o valor de retorno \u00e9 colocado tamb\u00e9m em um registrador. Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Argumentos ponto flutuante s\u00e3o passados nos registradores %xmm0 at\u00e9 %xmm7 . Valores de retorno inteiros ou ponteiros s\u00e3o colocados no registrador %rax . Valores de retorno ponto flutuante s\u00e3o colocados no registrador %xmm0 . Para chamar fun\u00e7\u00f5es usamos a instru\u00e7\u00e3o call seguido do endere\u00e7o de mem\u00f3ria da fun\u00e7\u00e3o. O gdb cria um \"apelido\" para estes endere\u00e7os de mem\u00f3ria usando o nome original da fun\u00e7\u00e3o no arquivo .c . Assim, estas instru\u00e7\u00f5es s\u00e3o mostradas, normalmente, como call func1 , por exemplo. Note que antes de cada call devemos preencher os argumentos nos registradores corretos. Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax (ou %xmm0 para ponto flutuante). N\u00e3o se esque\u00e7a da equival\u00eancia entre o tamanhos dos registradores e os tipos inteiros em C . Um resumo gr\u00e1fico pode ser visto nas figuras acima. 64 bits ( %rax , %rdi e outros que come\u00e7am com r ): long , unsigned long ou ponteiro; 32 bits ( %eax , %edi e outros que come\u00e7a com e e os que terminam em d como r10d ): int ou unsigned int ; 16 bits ( %ax , %di e outros com duas letras somente terminando em x ): short ou unsigned short 8 bits ( %al , %ah e outros com duas letras terminando em h ou l ): char ou unsigned char . Vamos agora praticar fazendo a tradu\u00e7\u00e3o de fun\u00e7\u00f5es que fazem aritm\u00e9tica simples entre inteiros (usando ou n\u00e3o ponteiros). O exemplo abaixo mostra todas as etapas que precisamos seguir para fazer a tradu\u00e7\u00e3o Assembly -> C. Exemplo guiado \u00b6 Dado o c\u00f3digo Assembly abaixo, fa\u00e7a sua tradu\u00e7\u00e3o para C 0000000000000000 <misterio1>: 0: 48 01 f7 add %rsi,%rdi 3: 48 8d 04 57 lea (%rdi,%rdx,2),%rax 7: c3 retq Assinatura da fun\u00e7\u00e3o \u00b6 Vamos come\u00e7ar pela assinatura da fun\u00e7\u00e3o. \u00c9 sempre \u00fatil identificar quais registradores s\u00e3o lidos antes de serem escritos. Isso nos ajuda a entender se um registrador \u00e9 um argumento da fun\u00e7\u00e3o ou se ele \u00e9 apenas usado como vari\u00e1vel local. Faremos isso escrevendo todos os registradores que podem ser argumentos em ordem e vendo se s\u00e3o lidos ou escritos primeiro: %rdi - lido primeiro ( add faz a opera\u00e7\u00e3o += ) %rsi - lido primeiro (no lado esquerdo do add ) %rdx - lido primeiro (no lado esquerdo do lea ) %rcx - n\u00e3o usado %r8 - n\u00e3o usado %r9 - n\u00e3o usado Logo, os registradores %rdi , %rsi e %rdx s\u00e3o argumentos da fun\u00e7\u00e3o. Consultando o box de arquitetura de computadores, vemos que a fun\u00e7\u00e3o recebe tr\u00eas argumentos do tipo long (pois usa os registradores de 64 bits). Note que o resultado das computa\u00e7\u00f5es \u00e9 guardado em %rax , que guarda sempre o retorno da fun\u00e7\u00e3o. Por usar a por\u00e7\u00e3o de 64 bits do registrador, o tipo de retorno tamb\u00e9m \u00e9 long . A assinatura da fun\u00e7\u00e3o \u00e9, portanto long misterio1(long a, long b, long c); Tip Ponteiros tamb\u00e9m usam os registradores de 64 bits. Por\u00e9m, olhando rapidamente o c\u00f3digo notamos que n\u00e3o h\u00e1 nenhum acesso a mem\u00f3ria. Logo, se trata realmente de long . O c\u00f3digo \u00b6 Vamos agora para o c\u00f3digo. Nossa primeira estrat\u00e9gia \u00e9 atribuir um nome para cada registrador. Os tr\u00eas registradores de argumentos j\u00e1 receberam os nomes a , b e c . Para deixar expl\u00edcito o papel do %rax vamos nome\u00e1-lo de retval . A primeira instru\u00e7\u00e3o add %rsi, %rdi realiza a adi\u00e7\u00e3o dos dois registradores e armazena em %rdi . Logo, sua tradu\u00e7\u00e3o direta seria: a += b ; A instru\u00e7\u00e3o lea (%rdi, %rdx, 2), %rax \u00e9 usada tanto para calcular endere\u00e7os de mem\u00f3ria quanto para aritm\u00e9tica simples. Vemos que \u00e9 o segundo caso pois, no c\u00f3digo seguinte, n\u00e3o acessamos a mem\u00f3ria com o valor calculado. Logo, podemos traduzir este trecho como retval = a + 2 * c ; Logo ap\u00f3s temos o ret , que \u00e9 traduzido como return retval ; Logo, nossa fun\u00e7\u00e3o \u00e9 traduzida como long misterio1 ( long a , long b , long c ){ long retval ; a += b ; retval = a + 2 * c ; return retval ; } Finalmente, podemos deixar nosso c\u00f3digo leg\u00edvel e escrev\u00ea-lo como long misterio1 ( long a , long b , long c ){ return a + b + 2 * c ; } Voc\u00ea pode verificar o c\u00f3digo original no arquivo exemplo1.c . O processo acima pode ser formalizado no seguinte algoritmo: Identifique quantos argumentos a fun\u00e7\u00e3o recebe Identifique os tipos de cada argumento (pode ser necess\u00e1rio olhar o c\u00f3digo assembly da fun\u00e7\u00e3o) D\u00ea um nome para cada registrador. Se um mesmo registrador \u00e9 usado com tamanhos diferentes ( %rdi e %edi s\u00e3o usados no c\u00f3digo), d\u00ea um nome diferente para cada tamanho. Fa\u00e7a a tradu\u00e7\u00e3o de cada instru\u00e7\u00e3o separadamente. Fique atento aos valores colocados em %rax e %eax perto do fim do c\u00f3digo. Esses valores ser\u00e3o retornados pela fun\u00e7\u00e3o. O c\u00f3digo gerado costuma ser ileg\u00edvel. Refatore-o para melhorar sua legibilidade. Tip A instru\u00e7\u00e3o lea pode ser usada tanto para aritm\u00e9tica quanto para c\u00e1lculo de endere\u00e7os. Para tirar a d\u00favida basta olhar se as pr\u00f3ximas instru\u00e7\u00f5es fazem acesso \u00e0 mem\u00f3ria com o endere\u00e7o calculado ou apenas usam o valor diretamente (aritm\u00e9tica). Os registradores de tamanhos menores s\u00e3o virtuais. Quanto escrevo em %ax estou escrevendo nos 16 bits menos significativos de %rax e de %eax tamb\u00e9m. Muitas instru\u00e7\u00f5es com operadores de 32bits zeram os 32bits superiores. Assim, vemos por exemplo a instru\u00e7\u00e3o mov $0, %eax sendo usada para zerar um long . Nesses casos \u00e9 necess\u00e1rio verificar se a fun\u00e7\u00e3o continua usando %eax (\u00e9 int mesmo) ou se ela magicamente passa a usar %rax (o tipo era long ). Pr\u00e1tica \u00b6 Vamos agora exercitar. Cada exerc\u00edcio faz um c\u00e1lculo diferente. Se houver alguma instru\u00e7\u00e3o desconhecida, pesquise-a no google para encontrar seu significado. Normalmente algo como \"asm x64 instruction\" + a instru\u00e7\u00e3o desconhecida d\u00e1 respostas corretas. Warning Usaremos o gdb para abrir os arquivos .o nesta aula. Este tipo de arquivo cont\u00e9m fun\u00e7\u00f5es compiladas, mas n\u00e3o \u00e9 um execut\u00e1vel completo por n\u00e3o ter uma fun\u00e7\u00e3o main . Arquivo ex1.o \u00b6 Exercise O c\u00f3digo abaixo foi retirado do arquivo ex1.o . Fa\u00e7a sua tradu\u00e7\u00e3o para C . 0000000000000000 <ex1>: 0: 89 f8 mov %edi,%eax 2: 29 f0 sub %esi,%eax 4: c3 retq Arquivo ex2.o \u00b6 Exercise Use o gdb para listar as fun\u00e7\u00f5es definidas em ex2.o e escreva-as abaixo. Exercise Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es acima para C Arquivo ex3.o \u00b6 A fun\u00e7\u00e3o abaixo foi obtida de ex3.o . 0000000000000000 <ex3>: 0: 8b 06 mov (%rsi),%eax 2: 0f af c0 imul %eax,%eax 5: 89 07 mov %eax,(%rdi) 7: c3 retq Exercise O qu\u00ea faz a instru\u00e7\u00e3o imul ? Exercise Traduza esta fun\u00e7\u00e3o para C . Fique atento ao tamanho dos registradores usados para identificar o tamanho dos vari\u00e1veis inteiras. Antes de prosseguir, valide suas solu\u00e7\u00f5es da se\u00e7\u00e3o anterior com o professor. Vamos agora trabalhar com execut\u00e1veis \"completos\". Vamos analisar n\u00e3o somente o c\u00f3digo das fun\u00e7\u00f5es mas tamb\u00e9m sua chamada. Arquivo ex4 \u00b6 Para come\u00e7ar! Use o gdb para obter o conte\u00fado das fun\u00e7\u00f5es main e ex4 . Dica : lembre-se do comando disas Localize a chamada da fun\u00e7\u00e3o ex4 no main. As intru\u00e7\u00f5es acima do call colocam os argumentos nos lugares corretos para ex4 rodar. Exercise Quantos argumentos a fun\u00e7\u00e3o recebe? Quais s\u00e3o seus valores? Exercise Traduza a fun\u00e7\u00e3o ex4 para C . Arquivo ex5 (desafio) \u00b6 Warning Este exerc\u00edcio \u00e9 avan\u00e7ado e necessita de pesquisa para ser realizado. Fa\u00e7a-o somente ap\u00f3s validar suas solu\u00e7\u00f5es dos anteriores com os professores. Neste exerc\u00edcio vamos nos aprofundar no uso de ponteiros. Vimos no ex3.o um exemplo de fun\u00e7\u00e3o que armazenava um valor calculado em um ponteiro. Agora veremos um exemplo completo que inclui a chamada de uma fun\u00e7\u00e3o recebendo um endere\u00e7o. O trecho abaixo copia os argumentos para os registradores corretos e chama a fun\u00e7\u00e3o. 60b: 48 8d 4c 24 08 lea 0x8(%rsp),%rcx 610: 48 8d 54 24 0c lea 0xc(%rsp),%rdx 615: be 03 00 00 00 mov $0x3,%esi 61a: bf 0a 00 00 00 mov $0xa,%edi 61f: e8 d6 ff ff ff callq 5fa <ex5> Exercise Identifique a partir dos tipos de dados colocados nos registradores qual o tipo dos argumentos da fun\u00e7\u00e3o. Exercise Qual s\u00e3o os endere\u00e7os passados para a fun\u00e7\u00e3o ex5 ? Escreva-os em fun\u00e7\u00e3o do registrador %rsp . Exercise Os endere\u00e7os acima s\u00e3o passados em quais registradores? Vamos agora ao c\u00f3digo de ex5 : 00000000000005fa <ex5>: 5fa: 89 f8 mov %edi,%eax 5fc: 48 89 d7 mov %rdx,%rdi 5ff: 99 cltd 600: f7 fe idiv %esi 602: 89 07 mov %eax,(%rdi) 604: 89 11 mov %edx,(%rcx) 606: c3 retq Exercise Como a instru\u00e7\u00e3o idiv funciona? Em quais registradores ela posiciona seu resultado? Em quais registradores ela espera a entrada? Exercise O qu\u00ea faz a instru\u00e7\u00e3o cltd ? Por qu\u00ea ela \u00e9 necess\u00e1ria? Exercise Fa\u00e7a a tradu\u00e7\u00e3o de ex5 para C . Conferindo tudo! Agora que terminou todos os exerc\u00edcios, confira suas tradu\u00e7\u00f5es com os gabaritos dispon\u00edveis no arquivo fontes.zip . Atividade para entrega! \u00b6 Aula com atividade para entrega . Confira seu reposit\u00f3rio de entregas do classroom! Aten\u00e7\u00e3o! Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de atv . Como come\u00e7ar? Leia o README.md dispon\u00edvel na pasta da atividade para descobrir como resolver e entregar. Prazo! Confira o prazo de entrega no menu Entregas e Prazos Hackerlab \u00b6 Foi liberado o enunciado do primeiro lab! Confira em Hackerlab no menu Labs ! Aten\u00e7\u00e3o! Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de lab .","title":"04 -  Fun\u00e7\u00f5es"},{"location":"aulas/04-funcoes-mov/#04-funcoes","text":"Neste handout vamos trabalhar pela primeira vez na tradu\u00e7\u00e3o reversa de programas em Assembly para C . Nas \u00faltimas aulas vimos as instru\u00e7\u00f5es mov e add e na aula de hoje vimos uma tabela grande com as instru\u00e7\u00f5es aritm\u00e9ticas ( add , sub , mul , imul , div , etc). Como em todas as aulas, veremos hoje um detalhe a mais sobre arquitetura x64 : chamadas de fun\u00e7\u00f5es e argumentos.","title":"04 -  Fun\u00e7\u00f5es"},{"location":"aulas/04-funcoes-mov/#funcoes-e-seus-argumentos","text":"Em x64 os argumentos das fun\u00e7\u00f5es s\u00e3o passados nos registradores e o valor de retorno \u00e9 colocado tamb\u00e9m em um registrador. Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Argumentos ponto flutuante s\u00e3o passados nos registradores %xmm0 at\u00e9 %xmm7 . Valores de retorno inteiros ou ponteiros s\u00e3o colocados no registrador %rax . Valores de retorno ponto flutuante s\u00e3o colocados no registrador %xmm0 . Para chamar fun\u00e7\u00f5es usamos a instru\u00e7\u00e3o call seguido do endere\u00e7o de mem\u00f3ria da fun\u00e7\u00e3o. O gdb cria um \"apelido\" para estes endere\u00e7os de mem\u00f3ria usando o nome original da fun\u00e7\u00e3o no arquivo .c . Assim, estas instru\u00e7\u00f5es s\u00e3o mostradas, normalmente, como call func1 , por exemplo. Note que antes de cada call devemos preencher os argumentos nos registradores corretos. Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax (ou %xmm0 para ponto flutuante). N\u00e3o se esque\u00e7a da equival\u00eancia entre o tamanhos dos registradores e os tipos inteiros em C . Um resumo gr\u00e1fico pode ser visto nas figuras acima. 64 bits ( %rax , %rdi e outros que come\u00e7am com r ): long , unsigned long ou ponteiro; 32 bits ( %eax , %edi e outros que come\u00e7a com e e os que terminam em d como r10d ): int ou unsigned int ; 16 bits ( %ax , %di e outros com duas letras somente terminando em x ): short ou unsigned short 8 bits ( %al , %ah e outros com duas letras terminando em h ou l ): char ou unsigned char . Vamos agora praticar fazendo a tradu\u00e7\u00e3o de fun\u00e7\u00f5es que fazem aritm\u00e9tica simples entre inteiros (usando ou n\u00e3o ponteiros). O exemplo abaixo mostra todas as etapas que precisamos seguir para fazer a tradu\u00e7\u00e3o Assembly -> C.","title":"Fun\u00e7\u00f5es e seus argumentos"},{"location":"aulas/04-funcoes-mov/#exemplo-guiado","text":"Dado o c\u00f3digo Assembly abaixo, fa\u00e7a sua tradu\u00e7\u00e3o para C 0000000000000000 <misterio1>: 0: 48 01 f7 add %rsi,%rdi 3: 48 8d 04 57 lea (%rdi,%rdx,2),%rax 7: c3 retq","title":"Exemplo guiado"},{"location":"aulas/04-funcoes-mov/#assinatura-da-funcao","text":"Vamos come\u00e7ar pela assinatura da fun\u00e7\u00e3o. \u00c9 sempre \u00fatil identificar quais registradores s\u00e3o lidos antes de serem escritos. Isso nos ajuda a entender se um registrador \u00e9 um argumento da fun\u00e7\u00e3o ou se ele \u00e9 apenas usado como vari\u00e1vel local. Faremos isso escrevendo todos os registradores que podem ser argumentos em ordem e vendo se s\u00e3o lidos ou escritos primeiro: %rdi - lido primeiro ( add faz a opera\u00e7\u00e3o += ) %rsi - lido primeiro (no lado esquerdo do add ) %rdx - lido primeiro (no lado esquerdo do lea ) %rcx - n\u00e3o usado %r8 - n\u00e3o usado %r9 - n\u00e3o usado Logo, os registradores %rdi , %rsi e %rdx s\u00e3o argumentos da fun\u00e7\u00e3o. Consultando o box de arquitetura de computadores, vemos que a fun\u00e7\u00e3o recebe tr\u00eas argumentos do tipo long (pois usa os registradores de 64 bits). Note que o resultado das computa\u00e7\u00f5es \u00e9 guardado em %rax , que guarda sempre o retorno da fun\u00e7\u00e3o. Por usar a por\u00e7\u00e3o de 64 bits do registrador, o tipo de retorno tamb\u00e9m \u00e9 long . A assinatura da fun\u00e7\u00e3o \u00e9, portanto long misterio1(long a, long b, long c); Tip Ponteiros tamb\u00e9m usam os registradores de 64 bits. Por\u00e9m, olhando rapidamente o c\u00f3digo notamos que n\u00e3o h\u00e1 nenhum acesso a mem\u00f3ria. Logo, se trata realmente de long .","title":"Assinatura da fun\u00e7\u00e3o"},{"location":"aulas/04-funcoes-mov/#o-codigo","text":"Vamos agora para o c\u00f3digo. Nossa primeira estrat\u00e9gia \u00e9 atribuir um nome para cada registrador. Os tr\u00eas registradores de argumentos j\u00e1 receberam os nomes a , b e c . Para deixar expl\u00edcito o papel do %rax vamos nome\u00e1-lo de retval . A primeira instru\u00e7\u00e3o add %rsi, %rdi realiza a adi\u00e7\u00e3o dos dois registradores e armazena em %rdi . Logo, sua tradu\u00e7\u00e3o direta seria: a += b ; A instru\u00e7\u00e3o lea (%rdi, %rdx, 2), %rax \u00e9 usada tanto para calcular endere\u00e7os de mem\u00f3ria quanto para aritm\u00e9tica simples. Vemos que \u00e9 o segundo caso pois, no c\u00f3digo seguinte, n\u00e3o acessamos a mem\u00f3ria com o valor calculado. Logo, podemos traduzir este trecho como retval = a + 2 * c ; Logo ap\u00f3s temos o ret , que \u00e9 traduzido como return retval ; Logo, nossa fun\u00e7\u00e3o \u00e9 traduzida como long misterio1 ( long a , long b , long c ){ long retval ; a += b ; retval = a + 2 * c ; return retval ; } Finalmente, podemos deixar nosso c\u00f3digo leg\u00edvel e escrev\u00ea-lo como long misterio1 ( long a , long b , long c ){ return a + b + 2 * c ; } Voc\u00ea pode verificar o c\u00f3digo original no arquivo exemplo1.c . O processo acima pode ser formalizado no seguinte algoritmo: Identifique quantos argumentos a fun\u00e7\u00e3o recebe Identifique os tipos de cada argumento (pode ser necess\u00e1rio olhar o c\u00f3digo assembly da fun\u00e7\u00e3o) D\u00ea um nome para cada registrador. Se um mesmo registrador \u00e9 usado com tamanhos diferentes ( %rdi e %edi s\u00e3o usados no c\u00f3digo), d\u00ea um nome diferente para cada tamanho. Fa\u00e7a a tradu\u00e7\u00e3o de cada instru\u00e7\u00e3o separadamente. Fique atento aos valores colocados em %rax e %eax perto do fim do c\u00f3digo. Esses valores ser\u00e3o retornados pela fun\u00e7\u00e3o. O c\u00f3digo gerado costuma ser ileg\u00edvel. Refatore-o para melhorar sua legibilidade. Tip A instru\u00e7\u00e3o lea pode ser usada tanto para aritm\u00e9tica quanto para c\u00e1lculo de endere\u00e7os. Para tirar a d\u00favida basta olhar se as pr\u00f3ximas instru\u00e7\u00f5es fazem acesso \u00e0 mem\u00f3ria com o endere\u00e7o calculado ou apenas usam o valor diretamente (aritm\u00e9tica). Os registradores de tamanhos menores s\u00e3o virtuais. Quanto escrevo em %ax estou escrevendo nos 16 bits menos significativos de %rax e de %eax tamb\u00e9m. Muitas instru\u00e7\u00f5es com operadores de 32bits zeram os 32bits superiores. Assim, vemos por exemplo a instru\u00e7\u00e3o mov $0, %eax sendo usada para zerar um long . Nesses casos \u00e9 necess\u00e1rio verificar se a fun\u00e7\u00e3o continua usando %eax (\u00e9 int mesmo) ou se ela magicamente passa a usar %rax (o tipo era long ).","title":"O c\u00f3digo"},{"location":"aulas/04-funcoes-mov/#pratica","text":"Vamos agora exercitar. Cada exerc\u00edcio faz um c\u00e1lculo diferente. Se houver alguma instru\u00e7\u00e3o desconhecida, pesquise-a no google para encontrar seu significado. Normalmente algo como \"asm x64 instruction\" + a instru\u00e7\u00e3o desconhecida d\u00e1 respostas corretas. Warning Usaremos o gdb para abrir os arquivos .o nesta aula. Este tipo de arquivo cont\u00e9m fun\u00e7\u00f5es compiladas, mas n\u00e3o \u00e9 um execut\u00e1vel completo por n\u00e3o ter uma fun\u00e7\u00e3o main .","title":"Pr\u00e1tica"},{"location":"aulas/04-funcoes-mov/#arquivo-ex1o","text":"Exercise O c\u00f3digo abaixo foi retirado do arquivo ex1.o . Fa\u00e7a sua tradu\u00e7\u00e3o para C . 0000000000000000 <ex1>: 0: 89 f8 mov %edi,%eax 2: 29 f0 sub %esi,%eax 4: c3 retq","title":"Arquivo ex1.o"},{"location":"aulas/04-funcoes-mov/#arquivo-ex2o","text":"Exercise Use o gdb para listar as fun\u00e7\u00f5es definidas em ex2.o e escreva-as abaixo. Exercise Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es acima para C","title":"Arquivo ex2.o"},{"location":"aulas/04-funcoes-mov/#arquivo-ex3o","text":"A fun\u00e7\u00e3o abaixo foi obtida de ex3.o . 0000000000000000 <ex3>: 0: 8b 06 mov (%rsi),%eax 2: 0f af c0 imul %eax,%eax 5: 89 07 mov %eax,(%rdi) 7: c3 retq Exercise O qu\u00ea faz a instru\u00e7\u00e3o imul ? Exercise Traduza esta fun\u00e7\u00e3o para C . Fique atento ao tamanho dos registradores usados para identificar o tamanho dos vari\u00e1veis inteiras. Antes de prosseguir, valide suas solu\u00e7\u00f5es da se\u00e7\u00e3o anterior com o professor. Vamos agora trabalhar com execut\u00e1veis \"completos\". Vamos analisar n\u00e3o somente o c\u00f3digo das fun\u00e7\u00f5es mas tamb\u00e9m sua chamada.","title":"Arquivo ex3.o"},{"location":"aulas/04-funcoes-mov/#arquivo-ex4","text":"Para come\u00e7ar! Use o gdb para obter o conte\u00fado das fun\u00e7\u00f5es main e ex4 . Dica : lembre-se do comando disas Localize a chamada da fun\u00e7\u00e3o ex4 no main. As intru\u00e7\u00f5es acima do call colocam os argumentos nos lugares corretos para ex4 rodar. Exercise Quantos argumentos a fun\u00e7\u00e3o recebe? Quais s\u00e3o seus valores? Exercise Traduza a fun\u00e7\u00e3o ex4 para C .","title":"Arquivo ex4"},{"location":"aulas/04-funcoes-mov/#arquivo-ex5-desafio","text":"Warning Este exerc\u00edcio \u00e9 avan\u00e7ado e necessita de pesquisa para ser realizado. Fa\u00e7a-o somente ap\u00f3s validar suas solu\u00e7\u00f5es dos anteriores com os professores. Neste exerc\u00edcio vamos nos aprofundar no uso de ponteiros. Vimos no ex3.o um exemplo de fun\u00e7\u00e3o que armazenava um valor calculado em um ponteiro. Agora veremos um exemplo completo que inclui a chamada de uma fun\u00e7\u00e3o recebendo um endere\u00e7o. O trecho abaixo copia os argumentos para os registradores corretos e chama a fun\u00e7\u00e3o. 60b: 48 8d 4c 24 08 lea 0x8(%rsp),%rcx 610: 48 8d 54 24 0c lea 0xc(%rsp),%rdx 615: be 03 00 00 00 mov $0x3,%esi 61a: bf 0a 00 00 00 mov $0xa,%edi 61f: e8 d6 ff ff ff callq 5fa <ex5> Exercise Identifique a partir dos tipos de dados colocados nos registradores qual o tipo dos argumentos da fun\u00e7\u00e3o. Exercise Qual s\u00e3o os endere\u00e7os passados para a fun\u00e7\u00e3o ex5 ? Escreva-os em fun\u00e7\u00e3o do registrador %rsp . Exercise Os endere\u00e7os acima s\u00e3o passados em quais registradores? Vamos agora ao c\u00f3digo de ex5 : 00000000000005fa <ex5>: 5fa: 89 f8 mov %edi,%eax 5fc: 48 89 d7 mov %rdx,%rdi 5ff: 99 cltd 600: f7 fe idiv %esi 602: 89 07 mov %eax,(%rdi) 604: 89 11 mov %edx,(%rcx) 606: c3 retq Exercise Como a instru\u00e7\u00e3o idiv funciona? Em quais registradores ela posiciona seu resultado? Em quais registradores ela espera a entrada? Exercise O qu\u00ea faz a instru\u00e7\u00e3o cltd ? Por qu\u00ea ela \u00e9 necess\u00e1ria? Exercise Fa\u00e7a a tradu\u00e7\u00e3o de ex5 para C . Conferindo tudo! Agora que terminou todos os exerc\u00edcios, confira suas tradu\u00e7\u00f5es com os gabaritos dispon\u00edveis no arquivo fontes.zip .","title":"Arquivo ex5 (desafio)"},{"location":"aulas/04-funcoes-mov/#atividade-para-entrega","text":"Aula com atividade para entrega . Confira seu reposit\u00f3rio de entregas do classroom! Aten\u00e7\u00e3o! Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de atv . Como come\u00e7ar? Leia o README.md dispon\u00edvel na pasta da atividade para descobrir como resolver e entregar. Prazo! Confira o prazo de entrega no menu Entregas e Prazos","title":"Atividade para entrega!"},{"location":"aulas/04-funcoes-mov/#hackerlab","text":"Foi liberado o enunciado do primeiro lab! Confira em Hackerlab no menu Labs ! Aten\u00e7\u00e3o! Fa\u00e7a git pull no seu reposit\u00f3rio de entregas que ir\u00e1 aparecer uma nova pasta dentro de lab .","title":"Hackerlab"},{"location":"aulas/05-condicionais/","text":"05 - Condicionais \u00b6 Express\u00f5es booleanas \u00b6 Vimos na expositiva que toda opera\u00e7\u00e3o aritm\u00e9tica preenche as flags CF , ZF , SF e OF e que podemos usar estas flags para montar express\u00f5es booleanas com as instru\u00e7\u00f5es set* . Simulador! Links para o simulador utilizado em aula: Direto: https://users.dickinson.edu/~braught/kands/KandS2/datapath.html Geral: https://users.dickinson.edu/~braught/kands/kands.html A tabela abaixo mostra as instru\u00e7\u00f5es respons\u00e1veis por cada tipo de express\u00e3o booleana. Tamb\u00e9m vimos que podemos preencher estas flags usando as instru\u00e7\u00f5es cmp e test , que executam opera\u00e7\u00f5es aritm\u00e9ticas (subtra\u00e7\u00e3o e E bit a bit) mas n\u00e3o guardam o resultado. Vamos analisar o c\u00f3digo assembly da fun\u00e7\u00e3o igual . Por enquanto n\u00e3o precisa abrir o gdb nem c\u00f3digo algum, apenas fa\u00e7a a an\u00e1lise direto neste material! int igual ( int a , int b ) { return a == b ; } 0000000000000000 < igual > : 0: 39 f7 cmp %esi , %edi 2: 0 f 94 c0 sete %al 5: 0 f b6 c0 movzbl %al , %eax 8: c3 retq A compara\u00e7\u00e3o a == b \u00e9 feita primeiro executando cmp entre os argumentos %edi e %esi e depois usando sete ( set equal ) para atribuir 1 em %al se %edi == %esi e 0 caso contr\u00e1rio. Por fim, temos a instru\u00e7\u00e3o movzbl , que faz o cast de char ( %al ) para int ( %eax ). Lembre-se que as instru\u00e7\u00f5es set* s\u00f3 modificam os primeiros 8 bits de %eax . O restante continua com o valor antigo. Usamos movzbl para extender o n\u00famero em %al para ocupar todo %eax . Tip As instru\u00e7\u00f5es de convers\u00e3o de tipos s\u00e3o bastante frequentes em Assembly, principalmente para expandir valores colocados em registradores menores para registradores maiores. Elas seguem a seguinte regra: MOVtsd t pode ser z para tipos unsigned (completando com **z**eros) e s para tipos signed (completando com o bit de **s**inal). s \u00e9 o tamanho do registrador fonte seguindo a nota\u00e7\u00e3o b para 1 byte, w para 2 bytes, l para 4 bytes e q para 8 bytes. d \u00e9 o tamanho do registrador destino, seguinto a mesma nota\u00e7\u00e3o acima. Por exemplo, a instru\u00e7\u00e3o MOVZWQ converte um unsigned short para um unsigned long . Convers\u00f5es de 4 para 8 bytes muitas vezes s\u00e3o feitas com a instru\u00e7\u00e3o cltq , que extende (com sinal) %eax para %rax . Uma boa refer\u00eancia \u00e9 este site da Oracle . Vamos agora praticar. Mas antes, relembre da aula anterior a os registradores e a ordem em que os par\u00e2metros da fun\u00e7\u00e3o s\u00e3o passados: Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax . Registradores: Pronto! Nos 3 exerc\u00edcios abaixo temos fun\u00e7\u00f5es que avaliam uma (ou mais) express\u00f5es booleanas entre seus argumentos e retornam o resultado. Arquivo ex1.o \u00b6 Reconstrua a fun\u00e7\u00e3o ex1 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex1 : 0 x0000000000000000 <+ 0 > : cmp $0xa , %edi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho do argumento de ex1 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o em um arquivo .c . Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o, ou utilize o gdb, conforme a pr\u00f3xima dica! Tip Uma outra maneira de conferir se sua solu\u00e7\u00e3o est\u00e1 correta \u00e9 compilar e conferir no gdb se a sua solu\u00e7\u00e3o produz o mesmo ASM que o compilado disponibilizado pelo professor. Caso seu c\u00f3digo n\u00e3o possua fun\u00e7\u00e3o main, gere um .o utilizando a flag -c . Veja o Exemplo de compila\u00e7\u00e3o sem fun\u00e7\u00e3o main: $ gcc -Og -g -Wall -std = c99 -c ex_resposta.c -o ex1_resp.o Ent\u00e3o, abra o gdb e confira se o ASM gerado confere com o disponibilizado pelo professor! Arquivo ex2.o \u00b6 Reconstrua a fun\u00e7\u00e3o ex2 a partir do c\u00f3digo assembly abaixo Dump of assembler code for function ex2 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setbe %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho dos argumentos de ex2 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o utilizando compara\u00e7\u00e3o do ASM (dica nesta aula), com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o. Arquivo ex3.o \u00b6 Reconstrua a fun\u00e7\u00e3o ex3 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex3 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setg %dl 0 x000000000000000c <+ 12 > : and %edx , %eax 0 x000000000000000e <+ 14 > : movzbl %al , %eax 0 x0000000000000011 <+ 17 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho dos argumentos de ex3 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega. Condicionais \u00b6 Vimos na segunda parte expositiva que Assembly possui apenas instru\u00e7\u00f5es de pulos condicionais ( j* onde * representa uma compara\u00e7\u00e3o usando as mesmas abrevia\u00e7\u00f5es de set* ) e n\u00e3o condicionais ( jmp ). Vimos tamb\u00e9m que a combina\u00e7\u00e3o destas instru\u00e7\u00f5es com cmp e test \u00e9 equivalente \u00e0 dupla de comandos if ( cond - booleana ) { goto label ; } A tabela abaixo mostra as opera\u00e7\u00f5es de saltos condicionais. Exemplo guiado \u00b6 Vamos agora fazer um exemplo guiado. Analisaremos o seguinte c\u00f3digo: 0000000000000000 < eh_par >: 0 : 40 f6 c7 01 test $0x1 , % dil 4 : 74 06 je c < eh_par + 0xc > 6 : b8 00 00 00 00 mov $0x0 , % eax b : c3 retq c : b8 01 00 00 00 mov $0x1 , % eax 11 : c3 retq Pares de instru\u00e7\u00f5es test-j* ou cmp-j* s\u00e3o comumente usadas para representar a constru\u00e7\u00e3o if-goto . Exercise O nome da fun\u00e7\u00e3o d\u00e1 uma dica de seu valor de retorno. Voc\u00ea consegue entender o porqu\u00ea test $1, %dil faz isto? Dica: Escreva o teste exato que a fun\u00e7\u00e3o faz. Vamos agora traduzir a fun\u00e7\u00e3o eh_par para gotoC . As linhas 0-4 s\u00e3o transformadas em um par if-goto . O restante s\u00e3o instru\u00e7\u00f5es que j\u00e1 conhecemos. int eh_par ( long a ) { if ( a & 1 == 0 ) goto if1 ; return 0 ; if1 : return 1 ; } Tiramos ent\u00e3o o goto e levando em conta sua resposta no item anterior, ficamos com o seguinte c\u00f3digo. Note que precisamos negar a compara\u00e7\u00e3o feita no c\u00f3digo anterior! int eh_par ( long a ) { if ( a % 2 != 0 ) { return 0 ; } return 1 ; } Podemos observar duas coisas no c\u00f3digo assembly gerado: O c\u00f3digo que estava dentro do if foi colocado ap\u00f3s o c\u00f3digo que estava fora do if! O compilador pode mudar a ordem dos nossos blocos de c\u00f3digo se for conveniente (para ele, n\u00e3o para n\u00f3s). A constru\u00e7\u00e3o test-j* e cmp-j* pode ser mapeada diretamente para if-goto . Por\u00e9m, reconstruir um c\u00f3digo leg\u00edvel requer, muitas vezes, mudar c\u00f3digo de lugar. Vamos agora praticar com alguns exerc\u00edcios simples: Arquivo ex4.o \u00b6 Veja o c\u00f3digo abaixo Dump of assembler code for function fun4 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : jle 0xf < fun4 + 15 > 0 x0000000000000005 <+ 5 > : mov $0x2 , %eax 0 x000000000000000a <+ 10 > : imul %rsi , %rax 0 x000000000000000e <+ 14 > : retq 0 x000000000000000f <+ 15 > : mov $0x1 , %eax 0 x0000000000000014 <+ 20 > : jmp 0xa < fun4 + 10 > End of assembler dump. Exercise Qual express\u00e3o booleana \u00e9 testada? Exercise Fa\u00e7a a tradu\u00e7\u00e3o desta fun\u00e7\u00e3o para gotoC . Exercise Transforme o c\u00f3digo acima em C leg\u00edvel. Arquivo ex5.o \u00b6 Veja o c\u00f3digo da fun\u00e7\u00e3o abaixo. Dump of assembler code for function ex5 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : setg %dl 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setle %al 0 x000000000000000c <+ 12 > : test %al , %dl 0 x000000000000000e <+ 14 > : jne 0x15 < ex5 + 21 > 0 x0000000000000010 <+ 16 > : lea -0 x2 ( %rsi ), %rax 0 x0000000000000014 <+ 20 > : retq 0 x0000000000000015 <+ 21 > : lea 0x5 ( %rdi ), %rax 0 x0000000000000019 <+ 25 > : retq End of assembler dump. Exercise Qual s\u00e3o as express\u00f5es booleanas testadas? (Dica: s\u00e3o 3, assim como no exerc\u00edcio 3). Exercise Fa\u00e7a uma tradu\u00e7\u00e3o para gotoC . Exercise Transforme seu c\u00f3digo acima para C leg\u00edvel. Exemplo guiado II \u00b6 Veremos agora um exemplo if/else : int exemplo2 ( long a , long b ) { long c ; if ( a >= 5 && b <= 0 ) { c = a + b ; } else { c = a - b ; } return c ; } Seu assembly correspondente, quando compilado com gcc -Og -c \u00e9 0000000000000000 < exemplo2 > : 0: 48 83 ff 04 cmp $0x4 , %rdi 4: 0 f 9 f c2 setg %dl 7: 48 85 f6 test %rsi , %rsi a: 0 f 9 e c0 setle %al d: 84 c2 test %al , %dl f: 75 07 jne 18 < exemplo2 + 0x18 > 11: 48 89 f8 mov %rdi , %rax 14: 48 29 f0 sub %rsi , %rax 17: c3 retq 18: 48 8 d 04 37 lea ( %rdi , %rsi , 1 ), %rax 1 c: c3 retq Primeiramente, notamos que a fun\u00e7\u00e3o recebe dois argumentos (pois s\u00f3 utiliza %rdi e %rsi ) e que ambos s\u00e3o tratados como long . Vamos ent\u00e3o \u00e0s express\u00f5es booleanas. Existem tr\u00eas express\u00f5es boolenas: cmp - setg (linhas 0-4 ) compara %rdi com 4 e seta %dl=1 se %rdi>4 (**g**reater) test-setle (linhas 7-a ) compara %rsi com 0 e seta %al=1 se %rsi<=0 (**l**ess or **e**qual). test (linha d ) entre %dl e %al . O resultado n\u00e3o \u00e9 armazenado. Logo abaixo do \u00faltimo test temos um jne (linha f ), acr\u00f4nimo para **j**ump if **n**ot **e**qual. Ou seja, fazemos o jump se %dl && %al for verdadeiro. Logo em seguida temos instru\u00e7\u00f5es aritm\u00e9ticas, que j\u00e1 estudamos nos \u00faltimos handouts. Assim como vimos nos slides, vamos converter este c\u00f3digo para gotoC primeiro. Assim como fizemos nos exerc\u00edcios de 1 a 3, criaremos uma vari\u00e1vel para as express\u00f5es booleanas 1 e 2 e substituiremos as instru\u00e7\u00f5es test-jne (linhas d-f ) por um par if-goto . Veja abaixo: int exemplo2 ( long a , long b ) { long retval ; int expr1 = a > 4 ; int expr2 = b <= 0 ; if ( expr1 && expr2 ) goto if1 ; retval = a ; retval -= b ; return retval ; if1 : retval = a + b ; return retval ; } Podemos ent\u00e3o melhorar tornar este c\u00f3digo mais leg\u00edvel, resultando no seguinte: int exemplo2 ( long a , long b ) { if ( a > 4 && b <= 0 ) { return a + b ; } else { return a - b ; } } Duas coisas importantes podem ser vistas neste c\u00f3digo As compara\u00e7\u00f5es n\u00e3o s\u00e3o exatamente iguais ( a>4 e a>=5 ), mas s\u00e3o equivalentes. O compilador pode trocar a ordem do if/else e colocar o else primeiro no Assembly gerado. Isto n\u00e3o altera o resultado da fun\u00e7\u00e3o, mas pode ser confuso de in\u00edcio. Arquivo ex6.o \u00b6 O exerc\u00edcio abaixo usa if-else . Dump of assembler code for function ex6 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : jle 0x8 < ex6 + 8 > 0 x0000000000000005 <+ 5 > : mov %rdi , %rsi 0 x0000000000000008 <+ 8 > : test %rdi , %rdi 0 x000000000000000b <+ 11 > : jle 0x10 < ex6 + 16 > 0 x000000000000000d <+ 13 > : neg %rsi 0 x0000000000000010 <+ 16 > : mov %esi , %eax 0 x0000000000000012 <+ 18 > : retq End of assembler dump. Exercise Traduza o c\u00f3digo acima para gotoC . Exercise Fa\u00e7a uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"05 - Condicionais"},{"location":"aulas/05-condicionais/#05-condicionais","text":"","title":"05 - Condicionais"},{"location":"aulas/05-condicionais/#expressoes-booleanas","text":"Vimos na expositiva que toda opera\u00e7\u00e3o aritm\u00e9tica preenche as flags CF , ZF , SF e OF e que podemos usar estas flags para montar express\u00f5es booleanas com as instru\u00e7\u00f5es set* . Simulador! Links para o simulador utilizado em aula: Direto: https://users.dickinson.edu/~braught/kands/KandS2/datapath.html Geral: https://users.dickinson.edu/~braught/kands/kands.html A tabela abaixo mostra as instru\u00e7\u00f5es respons\u00e1veis por cada tipo de express\u00e3o booleana. Tamb\u00e9m vimos que podemos preencher estas flags usando as instru\u00e7\u00f5es cmp e test , que executam opera\u00e7\u00f5es aritm\u00e9ticas (subtra\u00e7\u00e3o e E bit a bit) mas n\u00e3o guardam o resultado. Vamos analisar o c\u00f3digo assembly da fun\u00e7\u00e3o igual . Por enquanto n\u00e3o precisa abrir o gdb nem c\u00f3digo algum, apenas fa\u00e7a a an\u00e1lise direto neste material! int igual ( int a , int b ) { return a == b ; } 0000000000000000 < igual > : 0: 39 f7 cmp %esi , %edi 2: 0 f 94 c0 sete %al 5: 0 f b6 c0 movzbl %al , %eax 8: c3 retq A compara\u00e7\u00e3o a == b \u00e9 feita primeiro executando cmp entre os argumentos %edi e %esi e depois usando sete ( set equal ) para atribuir 1 em %al se %edi == %esi e 0 caso contr\u00e1rio. Por fim, temos a instru\u00e7\u00e3o movzbl , que faz o cast de char ( %al ) para int ( %eax ). Lembre-se que as instru\u00e7\u00f5es set* s\u00f3 modificam os primeiros 8 bits de %eax . O restante continua com o valor antigo. Usamos movzbl para extender o n\u00famero em %al para ocupar todo %eax . Tip As instru\u00e7\u00f5es de convers\u00e3o de tipos s\u00e3o bastante frequentes em Assembly, principalmente para expandir valores colocados em registradores menores para registradores maiores. Elas seguem a seguinte regra: MOVtsd t pode ser z para tipos unsigned (completando com **z**eros) e s para tipos signed (completando com o bit de **s**inal). s \u00e9 o tamanho do registrador fonte seguindo a nota\u00e7\u00e3o b para 1 byte, w para 2 bytes, l para 4 bytes e q para 8 bytes. d \u00e9 o tamanho do registrador destino, seguinto a mesma nota\u00e7\u00e3o acima. Por exemplo, a instru\u00e7\u00e3o MOVZWQ converte um unsigned short para um unsigned long . Convers\u00f5es de 4 para 8 bytes muitas vezes s\u00e3o feitas com a instru\u00e7\u00e3o cltq , que extende (com sinal) %eax para %rax . Uma boa refer\u00eancia \u00e9 este site da Oracle . Vamos agora praticar. Mas antes, relembre da aula anterior a os registradores e a ordem em que os par\u00e2metros da fun\u00e7\u00e3o s\u00e3o passados: Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax . Registradores: Pronto! Nos 3 exerc\u00edcios abaixo temos fun\u00e7\u00f5es que avaliam uma (ou mais) express\u00f5es booleanas entre seus argumentos e retornam o resultado.","title":"Express\u00f5es booleanas"},{"location":"aulas/05-condicionais/#arquivo-ex1o","text":"Reconstrua a fun\u00e7\u00e3o ex1 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex1 : 0 x0000000000000000 <+ 0 > : cmp $0xa , %edi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho do argumento de ex1 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o em um arquivo .c . Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o, ou utilize o gdb, conforme a pr\u00f3xima dica! Tip Uma outra maneira de conferir se sua solu\u00e7\u00e3o est\u00e1 correta \u00e9 compilar e conferir no gdb se a sua solu\u00e7\u00e3o produz o mesmo ASM que o compilado disponibilizado pelo professor. Caso seu c\u00f3digo n\u00e3o possua fun\u00e7\u00e3o main, gere um .o utilizando a flag -c . Veja o Exemplo de compila\u00e7\u00e3o sem fun\u00e7\u00e3o main: $ gcc -Og -g -Wall -std = c99 -c ex_resposta.c -o ex1_resp.o Ent\u00e3o, abra o gdb e confira se o ASM gerado confere com o disponibilizado pelo professor!","title":"Arquivo ex1.o"},{"location":"aulas/05-condicionais/#arquivo-ex2o","text":"Reconstrua a fun\u00e7\u00e3o ex2 a partir do c\u00f3digo assembly abaixo Dump of assembler code for function ex2 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setbe %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho dos argumentos de ex2 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o utilizando compara\u00e7\u00e3o do ASM (dica nesta aula), com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o.","title":"Arquivo ex2.o"},{"location":"aulas/05-condicionais/#arquivo-ex3o","text":"Reconstrua a fun\u00e7\u00e3o ex3 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex3 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setg %dl 0 x000000000000000c <+ 12 > : and %edx , %eax 0 x000000000000000e <+ 14 > : movzbl %al , %eax 0 x0000000000000011 <+ 17 > : retq End of assembler dump. Exercise Qual \u00e9 o tamanho dos argumentos de ex3 ? Ele \u00e9 signed ou unsigned ? Exercise Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega.","title":"Arquivo ex3.o"},{"location":"aulas/05-condicionais/#condicionais","text":"Vimos na segunda parte expositiva que Assembly possui apenas instru\u00e7\u00f5es de pulos condicionais ( j* onde * representa uma compara\u00e7\u00e3o usando as mesmas abrevia\u00e7\u00f5es de set* ) e n\u00e3o condicionais ( jmp ). Vimos tamb\u00e9m que a combina\u00e7\u00e3o destas instru\u00e7\u00f5es com cmp e test \u00e9 equivalente \u00e0 dupla de comandos if ( cond - booleana ) { goto label ; } A tabela abaixo mostra as opera\u00e7\u00f5es de saltos condicionais.","title":"Condicionais"},{"location":"aulas/05-condicionais/#exemplo-guiado","text":"Vamos agora fazer um exemplo guiado. Analisaremos o seguinte c\u00f3digo: 0000000000000000 < eh_par >: 0 : 40 f6 c7 01 test $0x1 , % dil 4 : 74 06 je c < eh_par + 0xc > 6 : b8 00 00 00 00 mov $0x0 , % eax b : c3 retq c : b8 01 00 00 00 mov $0x1 , % eax 11 : c3 retq Pares de instru\u00e7\u00f5es test-j* ou cmp-j* s\u00e3o comumente usadas para representar a constru\u00e7\u00e3o if-goto . Exercise O nome da fun\u00e7\u00e3o d\u00e1 uma dica de seu valor de retorno. Voc\u00ea consegue entender o porqu\u00ea test $1, %dil faz isto? Dica: Escreva o teste exato que a fun\u00e7\u00e3o faz. Vamos agora traduzir a fun\u00e7\u00e3o eh_par para gotoC . As linhas 0-4 s\u00e3o transformadas em um par if-goto . O restante s\u00e3o instru\u00e7\u00f5es que j\u00e1 conhecemos. int eh_par ( long a ) { if ( a & 1 == 0 ) goto if1 ; return 0 ; if1 : return 1 ; } Tiramos ent\u00e3o o goto e levando em conta sua resposta no item anterior, ficamos com o seguinte c\u00f3digo. Note que precisamos negar a compara\u00e7\u00e3o feita no c\u00f3digo anterior! int eh_par ( long a ) { if ( a % 2 != 0 ) { return 0 ; } return 1 ; } Podemos observar duas coisas no c\u00f3digo assembly gerado: O c\u00f3digo que estava dentro do if foi colocado ap\u00f3s o c\u00f3digo que estava fora do if! O compilador pode mudar a ordem dos nossos blocos de c\u00f3digo se for conveniente (para ele, n\u00e3o para n\u00f3s). A constru\u00e7\u00e3o test-j* e cmp-j* pode ser mapeada diretamente para if-goto . Por\u00e9m, reconstruir um c\u00f3digo leg\u00edvel requer, muitas vezes, mudar c\u00f3digo de lugar. Vamos agora praticar com alguns exerc\u00edcios simples:","title":"Exemplo guiado"},{"location":"aulas/05-condicionais/#arquivo-ex4o","text":"Veja o c\u00f3digo abaixo Dump of assembler code for function fun4 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : jle 0xf < fun4 + 15 > 0 x0000000000000005 <+ 5 > : mov $0x2 , %eax 0 x000000000000000a <+ 10 > : imul %rsi , %rax 0 x000000000000000e <+ 14 > : retq 0 x000000000000000f <+ 15 > : mov $0x1 , %eax 0 x0000000000000014 <+ 20 > : jmp 0xa < fun4 + 10 > End of assembler dump. Exercise Qual express\u00e3o booleana \u00e9 testada? Exercise Fa\u00e7a a tradu\u00e7\u00e3o desta fun\u00e7\u00e3o para gotoC . Exercise Transforme o c\u00f3digo acima em C leg\u00edvel.","title":"Arquivo ex4.o"},{"location":"aulas/05-condicionais/#arquivo-ex5o","text":"Veja o c\u00f3digo da fun\u00e7\u00e3o abaixo. Dump of assembler code for function ex5 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : setg %dl 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setle %al 0 x000000000000000c <+ 12 > : test %al , %dl 0 x000000000000000e <+ 14 > : jne 0x15 < ex5 + 21 > 0 x0000000000000010 <+ 16 > : lea -0 x2 ( %rsi ), %rax 0 x0000000000000014 <+ 20 > : retq 0 x0000000000000015 <+ 21 > : lea 0x5 ( %rdi ), %rax 0 x0000000000000019 <+ 25 > : retq End of assembler dump. Exercise Qual s\u00e3o as express\u00f5es booleanas testadas? (Dica: s\u00e3o 3, assim como no exerc\u00edcio 3). Exercise Fa\u00e7a uma tradu\u00e7\u00e3o para gotoC . Exercise Transforme seu c\u00f3digo acima para C leg\u00edvel.","title":"Arquivo ex5.o"},{"location":"aulas/05-condicionais/#exemplo-guiado-ii","text":"Veremos agora um exemplo if/else : int exemplo2 ( long a , long b ) { long c ; if ( a >= 5 && b <= 0 ) { c = a + b ; } else { c = a - b ; } return c ; } Seu assembly correspondente, quando compilado com gcc -Og -c \u00e9 0000000000000000 < exemplo2 > : 0: 48 83 ff 04 cmp $0x4 , %rdi 4: 0 f 9 f c2 setg %dl 7: 48 85 f6 test %rsi , %rsi a: 0 f 9 e c0 setle %al d: 84 c2 test %al , %dl f: 75 07 jne 18 < exemplo2 + 0x18 > 11: 48 89 f8 mov %rdi , %rax 14: 48 29 f0 sub %rsi , %rax 17: c3 retq 18: 48 8 d 04 37 lea ( %rdi , %rsi , 1 ), %rax 1 c: c3 retq Primeiramente, notamos que a fun\u00e7\u00e3o recebe dois argumentos (pois s\u00f3 utiliza %rdi e %rsi ) e que ambos s\u00e3o tratados como long . Vamos ent\u00e3o \u00e0s express\u00f5es booleanas. Existem tr\u00eas express\u00f5es boolenas: cmp - setg (linhas 0-4 ) compara %rdi com 4 e seta %dl=1 se %rdi>4 (**g**reater) test-setle (linhas 7-a ) compara %rsi com 0 e seta %al=1 se %rsi<=0 (**l**ess or **e**qual). test (linha d ) entre %dl e %al . O resultado n\u00e3o \u00e9 armazenado. Logo abaixo do \u00faltimo test temos um jne (linha f ), acr\u00f4nimo para **j**ump if **n**ot **e**qual. Ou seja, fazemos o jump se %dl && %al for verdadeiro. Logo em seguida temos instru\u00e7\u00f5es aritm\u00e9ticas, que j\u00e1 estudamos nos \u00faltimos handouts. Assim como vimos nos slides, vamos converter este c\u00f3digo para gotoC primeiro. Assim como fizemos nos exerc\u00edcios de 1 a 3, criaremos uma vari\u00e1vel para as express\u00f5es booleanas 1 e 2 e substituiremos as instru\u00e7\u00f5es test-jne (linhas d-f ) por um par if-goto . Veja abaixo: int exemplo2 ( long a , long b ) { long retval ; int expr1 = a > 4 ; int expr2 = b <= 0 ; if ( expr1 && expr2 ) goto if1 ; retval = a ; retval -= b ; return retval ; if1 : retval = a + b ; return retval ; } Podemos ent\u00e3o melhorar tornar este c\u00f3digo mais leg\u00edvel, resultando no seguinte: int exemplo2 ( long a , long b ) { if ( a > 4 && b <= 0 ) { return a + b ; } else { return a - b ; } } Duas coisas importantes podem ser vistas neste c\u00f3digo As compara\u00e7\u00f5es n\u00e3o s\u00e3o exatamente iguais ( a>4 e a>=5 ), mas s\u00e3o equivalentes. O compilador pode trocar a ordem do if/else e colocar o else primeiro no Assembly gerado. Isto n\u00e3o altera o resultado da fun\u00e7\u00e3o, mas pode ser confuso de in\u00edcio.","title":"Exemplo guiado II"},{"location":"aulas/05-condicionais/#arquivo-ex6o","text":"O exerc\u00edcio abaixo usa if-else . Dump of assembler code for function ex6 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : jle 0x8 < ex6 + 8 > 0 x0000000000000005 <+ 5 > : mov %rdi , %rsi 0 x0000000000000008 <+ 8 > : test %rdi , %rdi 0 x000000000000000b <+ 11 > : jle 0x10 < ex6 + 16 > 0 x000000000000000d <+ 13 > : neg %rsi 0 x0000000000000010 <+ 16 > : mov %esi , %eax 0 x0000000000000012 <+ 18 > : retq End of assembler dump. Exercise Traduza o c\u00f3digo acima para gotoC . Exercise Fa\u00e7a uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"Arquivo ex6.o"},{"location":"aulas/06-condicionais-funcoes/","text":"06 - Condicionais e fun\u00e7\u00f5es \u00b6 Na aula de hoje vamos revisar e praticar os conceitos de fun\u00e7\u00f5es e condicionais em Assembly. Teremos exerc\u00edcios simples de cada assunto e no fim alguns exerc\u00edcios para entrega que juntam coisas diferentes. Fun\u00e7\u00f5es e aritm\u00e9tica com LEA \u00b6 Todos os exerc\u00edcios da revis\u00e3o ser\u00e3o feitos com o arquivo exemplo1 (compilado a partir de exemplo1.c ). Vamos examinar tanto a fun\u00e7\u00e3o main quanto a fun\u00e7\u00e3o exemplo1 . Compile com: $ gcc -Og -Wall -std = c99 exemplo1.c -o exemplo1 Chamadas de fun\u00e7\u00f5es \u00b6 As chamadas de fun\u00e7\u00e3o s\u00e3o feitas usando a seguinte ordem para os argumentos inteiros: %rdi %rsi %rdx %rcx %r8 %r9 Esta ordem nunca muda . Veja abaixo um exemplo de chamada de fun\u00e7\u00e3o tirado do main de exemplo1 . 0 x01163 <+ 8 > : mov $0x6 , %r9d 0 x01169 <+ 14 > : mov $0x5 , %r8d 0 x0116f <+ 20 > : mov $0x4 , %ecx 0 x01174 <+ 25 > : mov $0x3 , %edx 0 x01179 <+ 30 > : mov $0x2 , %esi 0 x0117e <+ 35 > : mov $0x1 , %edi 0 x01183 <+ 40 > : call 0x1149 < exemplo1 > 0 x01188 <+ 45 > : lea 0xa ( %rax ), %esi Pergunta O valor do primeiro argumento da fun\u00e7\u00e3o \u00e9 6 1 Answer A ordem dos par\u00e2metros segue \u00e9 sempre a mesma vista na aula 04 . Mesmo que as instru\u00e7\u00f5es estejam em ordem diferente, %edi (ou uma de suas partes) \u00e9 sempre o primeiro par\u00e2metro. Exercise A instru\u00e7\u00e3o call realiza chamadas de fun\u00e7\u00e3o. Traduza a chamada de fun\u00e7\u00e3o acima para C . Answer exemplo1(1, 2, 3, 4, 5, 6) Vamos agora analisar o c\u00f3digo de exemplo1 : Dump of assembler code for function exemplo1 : 0 x01149 <+ 0 > : endbr64 0x0114d <+ 4 > : add %esi , %edi 0 x0114f <+ 6 > : add %edx , %edi 0 x01151 <+ 8 > : add %ecx , %edi 0 x01153 <+ 10 > : add %r8d , %edi 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax 0 x0115a <+ 17 > : ret Exercise Quantos par\u00e2metros a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Ela retorna algum valor? Se sim, qual seu tipo? Answer Pelos registradores utilizados, percebemos que a fun\u00e7\u00e3o tem seis par\u00e2metros, todos int . O retorno tamb\u00e9m \u00e9 int . Exercise Declare a fun\u00e7\u00e3o acima com base na sua resposta anterior. Answer int exemplo1(int a, int b, int c, int d, int e, int f); Exercise O que faz o conjunto de instru\u00e7\u00f5es add nas linhas +4 at\u00e9 +10 ? Escreva uma express\u00e3o em C equivalente. Answer Ela soma os primeiros 5 argumentos: a + b + c + e . Vemos na linha exemplo1+13 que colocamos um valor no registrador %eax e depois finalizamos a fun\u00e7\u00e3o usando ret . Este \u00e9 o segundo ponto que nunca muda: o valor de retorno de toda fun\u00e7\u00e3o \u00e9 colocado no registrador %rax (ou uma de suas partes menores). Neste exemplo, a instru\u00e7\u00e3o usada foi o LEA que relembraremos na se\u00e7\u00e3o a seguir. Opera\u00e7\u00f5es aritm\u00e9ticas usando LEA \u00b6 Se usada de maneira literal, a instru\u00e7\u00e3o LEA (Load Effective Address) serve para calcular o endere\u00e7o de uma vari\u00e1vel local e \u00e9 equivalente ao operador & em C . Por\u00e9m, ela \u00e9 frequentemente \"abusada\" para fazer aritm\u00e9tica. Um ponto importante quando usamos LEA \u00e9 que todos os operandos s\u00e3o registradores de 64 bits. Regra geral Se LEA for usada com o registrador %rsp ent\u00e3o ela sempre representa o operador & Se os registradores envolvidos foram usados como n\u00fameros inteiros em instru\u00e7\u00f5es anteriores, ent\u00e3o ela representa uma conta com os valores dos registradores. Vejamos o exemplo da fun\u00e7\u00e3o exemplo1 acima: lea ( %rdi , %r9 , 1 ), %eax 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax No exemplo acima LEA \u00e9 usada para fazer aritm\u00e9tica. Sabemos disso pois, na chamada traduzida na parte anterior, elas recebem n\u00fameros inteiros ( %r9d = 6 e %edi = 1 mais o resultado de sucessivas somas). Seu primeiro argumento segue a seguinte l\u00f3gica C ( %R1 , %R2 , S ) C \u00e9 uma constante %R1 \u00e9 um registrador %R2 \u00e9 um registrador (pode ser igual a %R1 ) S \u00e9 1, 2, 4 ou 8 (todos os tamanhos poss\u00edveis de registradores inteiros) A opera\u00e7\u00e3o acima calcula C + %R1 + (%R2 * S) . A opera\u00e7\u00e3o LEA nunca acessa a mem\u00f3ria , apenas move o resultado deste c\u00e1lculo para o registrador destino. Qualquer outra opera\u00e7\u00e3o que use a sintaxe acima est\u00e1 fazendo um acesso a mem\u00f3ria. LEA \u00e9 a \u00fanica exce\u00e7\u00e3o! Exercise Traduza a opera\u00e7\u00e3o abaixo para C 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax Answer Supondo que aux = a+b+c+d+e j\u00e1 foi calculado com o uso das instru\u00e7\u00f5es ADD , ent\u00e3o o LEA calcula aux + f*1 . Exercise Com estas informa\u00e7\u00f5es em m\u00e3os, traduza exemplo1 para C Dump of assembler code for function exemplo1 : 0 x01149 <+ 0 > : endbr64 0x0114d <+ 4 > : add %esi , %edi 0 x0114f <+ 6 > : add %edx , %edi 0 x01151 <+ 8 > : add %ecx , %edi 0 x01153 <+ 10 > : add %r8d , %edi 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax 0 x0115a <+ 17 > : ret Answer Confira no arquivo exemplo1.c Retorno de fun\u00e7\u00f5es \u00b6 Vamos terminar nossa revis\u00e3o analisando novamente a chamada de exemplo1 no main : 0 x01163 <+ 8 > : mov $0x6 , %r9d 0 x01169 <+ 14 > : mov $0x5 , %r8d 0 x0116f <+ 20 > : mov $0x4 , %ecx 0 x01174 <+ 25 > : mov $0x3 , %edx 0 x01179 <+ 30 > : mov $0x2 , %esi 0 x0117e <+ 35 > : mov $0x1 , %edi 0 x01183 <+ 40 > : call 0x1149 < exemplo1 > 0 x01188 <+ 45 > : lea 0xa ( %rax ), %esi Anteriormente j\u00e1 vimos que o call e os mov s acima fazem a chamada exemplo1(1,2,3,4,5,6) em C . A linha de baixo realiza uma opera\u00e7\u00e3o aritm\u00e9tica com %rax . Exercise Considerando que %rax armazena o valor de retorno de uma fun\u00e7\u00e3o, qual seria a tradu\u00e7\u00e3o para C do bloco de c\u00f3digo acima? Answer int esi = exemplo1(1, 2, 3, 4, 5, 6) + 10; Exerc\u00edcios combinados \u00b6 Warning Todos os exerc\u00edcios desta se\u00e7\u00e3o s\u00e3o para entrega. Voc\u00eas podem se conversar para faz\u00ea-los, mas cada um deve criar sua pr\u00f3pria solu\u00e7\u00e3o do zero. Todos os exerc\u00edcios j\u00e1 est\u00e3o dispon\u00edveis no seu reposit\u00f3rio de entregas da disciplina em atv/04-condicionais-funcoes . Leia o README dentro da pasta para mais informa\u00e7\u00f5es. Fun\u00e7\u00e3o ex1 : Aritm\u00e9tica e Express\u00f5es booleanas . \u00b6 Dump of assembler code for function ex1 : 0 x000 <+ 0 > : endbr64 0 x004 <+ 4 > : lea ( %rdi , %rsi , 1 ), %rax 0 x008 <+ 8 > : lea ( %rax , %rdx , 4 ), %rcx 0 x00c <+ 12 > : imul %rdi , %rdi 0 x010 <+ 16 > : lea ( %rdi , %rsi , 2 ), %rax 0 x014 <+ 20 > : add %rax , %rdx 0 x017 <+ 23 > : cmp %rdx , %rcx 0 x01a <+ 26 > : setge %al 0 x01d <+ 29 > : movzbl %al , %eax 0 x020 <+ 32 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Declare a fun\u00e7\u00e3o abaixo. Exercise As instru\u00e7\u00f5es LEA acima representam opera\u00e7\u00f5es aritm\u00e9ticas ou a opera\u00e7\u00e3o endere\u00e7o de & ? Como voc\u00ea fez esta identifica\u00e7\u00e3o? . Exercise Traduza as opera\u00e7\u00f5es das linhas ex1+0 at\u00e9 ex1+16 para C Exercise Nas linhas ex1+23 e ex1+26 \u00e9 feita uma compara\u00e7\u00e3o. Qual e entre quais registradores? Onde \u00e9 armazenado este resultado? Exercise O qu\u00ea faz a instru\u00e7\u00e3o movzbl em ex1+29 ? Juntando com a resposta da pergunta acima, traduza as instru\u00e7\u00f5es ex1+23 at\u00e9 ex1+32 para C . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes. Fun\u00e7\u00e3o ex2 : Chamadas de fun\u00e7\u00f5es e Condicionais . \u00b6 Quando analisar o c\u00f3digo do ex2 no gdb, utilize o arquivo ex2_ref para visualizar corretamente as chamadas de fun\u00e7\u00f5es. Seria uma boa tamb\u00e9m consultar as relocation entries no terminal com objdump -r ex2.o . Dump of assembler code for function ex2 : 0 x01132 <+ 0 > : endbr64 0 x01136 <+ 4 > : push %rbx 0 x01137 <+ 5 > : mov %rdi , %rbx 0 x0113a <+ 8 > : mov %rsi , %rdi 0 x0113d <+ 11 > : call 0x1129 < vezes2 > 0 x01142 <+ 16 > : cmp %rbx , %rax 0 x01145 <+ 19 > : jle 0x114a < ex2 + 24 > 0 x01147 <+ 21 > : add %rbx , %rbx 0 x0114a <+ 24 > : add %rbx , %rax 0 x0114d <+ 27 > : pop %rbx 0 x0114e <+ 28 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais s\u00e3o seus tipos? Declare-a abaixo. Vamos come\u00e7ar trabalhando na linha ex2+11 , na instru\u00e7\u00e3o call vezes2 . A chamada necessita usar o registrador %rdi , mas ele cont\u00e9m o primeiro argumento de ex2 . Exercise Em qual registrador \u00e9 guardado o primeiro argumento de ex2 ? Isso \u00e9 feito antes da chamada call . Exercise Qual vari\u00e1vel \u00e9 passada como argumento para a fun\u00e7\u00e3o vezes2 ? Exercise Escreva abaixo a invoca\u00e7\u00e3o de vezes2 . Voc\u00ea deve ter notado as instru\u00e7\u00f5es push/pop %rbx no come\u00e7o/fim da fun\u00e7\u00e3o. Toda fun\u00e7\u00e3o pode usar os registradores de argumentos (vistos na parte 1) e o de valor de retorno como quiserem. Se precisarem mexer nos outros registradores a pr\u00e1tica \u00e9 salv\u00e1-los na pilha no come\u00e7o da fun\u00e7\u00e3o e restaur\u00e1-los no fim. Assim n\u00e3o importa o que a fun\u00e7\u00e3o fa\u00e7a, para a fun\u00e7\u00e3o chamadora \u00e9 como se n\u00e3o houvesse havido nenhuma modifica\u00e7\u00e3o nos outros registradores. Vamos agora olhar a condicional na linha ex2+16 . Exercise Ap\u00f3s a chamada call , qual o conte\u00fado de %rax ? Exercise Juntando suas respostas nas quest\u00f5es de cima, qual \u00e9 a compara\u00e7\u00e3o feita nas linhas ex2+16, ex2+19 ? Exercise Com essas informa\u00e7\u00f5es em m\u00e3os, fa\u00e7a uma tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if+goto . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes. Fun\u00e7\u00e3o ex3 : Ponteiros e Express\u00f5es booleanas . \u00b6 Dump of assembler code for function ex3 : 0 x000 <+ 0 > : endbr64 0 x004 <+ 4 > : cmp %rsi , %rdi 0 x007 <+ 7 > : setl %al 0 x00a <+ 10 > : movzbl %al , %eax 0 x00d <+ 13 > : mov %eax ,( %rdx ) 0 x00f <+ 15 > : sete %al 0 x012 <+ 18 > : movzbl %al , %eax 0 x015 <+ 21 > : mov %eax ,( %rcx ) 0 x017 <+ 23 > : setg %al 0 x01a <+ 26 > : movzbl %al , %eax 0 x01d <+ 29 > : mov %eax ,( %r8 ) 0 x020 <+ 32 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? De quais tipos? Declare-a abaixo. Exercise A fun\u00e7\u00e3o acima faz v\u00e1rias compara\u00e7\u00f5es. Liste quais e entre quais argumentos. Exercise Onde \u00e9 armazenado o resultado de cada compara\u00e7\u00e3o? Exercise Com base em suas respostas acima, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha da fun\u00e7\u00e3o acima. Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes. Fun\u00e7\u00e3o ex4 : Ponteiros e Express\u00f5es booleanas . \u00b6 Dump of assembler code for function ex4 : 0 x00a <+ 0 > : endbr64 0x00e <+ 4 > : cmp $0x11 , %di 0 x012 <+ 8 > : jle 0x21 < ex4 + 23 > 0 x014 <+ 10 > : sub $0x41 , %esi 0 x017 <+ 13 > : cmp $0x1 , %sil 0 x01b <+ 17 > : ja 0x29 < ex4 + 31 > 0 x01d <+ 19 > : lea -0 x11 ( %rdi ), %eax 0 x020 <+ 22 > : ret 0x021 <+ 23 > : mov $0x12 , %eax 0 x026 <+ 28 > : sub %edi , %eax 0 x028 <+ 30 > : ret 0x029 <+ 31 > : mov $0xffffffff , %eax 0 x02e <+ 36 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? De quais tipos? Declare-a abaixo. Exercise A fun\u00e7\u00e3o acima faz v\u00e1rias compara\u00e7\u00f5es. Liste quais e entre quais argumentos. Exercise Onde \u00e9 armazenado o resultado de cada compara\u00e7\u00e3o? Exercise Com base em suas respostas acima, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha da fun\u00e7\u00e3o acima. Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"06 - Condicionais e fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#06-condicionais-e-funcoes","text":"Na aula de hoje vamos revisar e praticar os conceitos de fun\u00e7\u00f5es e condicionais em Assembly. Teremos exerc\u00edcios simples de cada assunto e no fim alguns exerc\u00edcios para entrega que juntam coisas diferentes.","title":"06 - Condicionais e fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#funcoes-e-aritmetica-com-lea","text":"Todos os exerc\u00edcios da revis\u00e3o ser\u00e3o feitos com o arquivo exemplo1 (compilado a partir de exemplo1.c ). Vamos examinar tanto a fun\u00e7\u00e3o main quanto a fun\u00e7\u00e3o exemplo1 . Compile com: $ gcc -Og -Wall -std = c99 exemplo1.c -o exemplo1","title":"Fun\u00e7\u00f5es e aritm\u00e9tica com LEA"},{"location":"aulas/06-condicionais-funcoes/#chamadas-de-funcoes","text":"As chamadas de fun\u00e7\u00e3o s\u00e3o feitas usando a seguinte ordem para os argumentos inteiros: %rdi %rsi %rdx %rcx %r8 %r9 Esta ordem nunca muda . Veja abaixo um exemplo de chamada de fun\u00e7\u00e3o tirado do main de exemplo1 . 0 x01163 <+ 8 > : mov $0x6 , %r9d 0 x01169 <+ 14 > : mov $0x5 , %r8d 0 x0116f <+ 20 > : mov $0x4 , %ecx 0 x01174 <+ 25 > : mov $0x3 , %edx 0 x01179 <+ 30 > : mov $0x2 , %esi 0 x0117e <+ 35 > : mov $0x1 , %edi 0 x01183 <+ 40 > : call 0x1149 < exemplo1 > 0 x01188 <+ 45 > : lea 0xa ( %rax ), %esi Pergunta O valor do primeiro argumento da fun\u00e7\u00e3o \u00e9 6 1 Answer A ordem dos par\u00e2metros segue \u00e9 sempre a mesma vista na aula 04 . Mesmo que as instru\u00e7\u00f5es estejam em ordem diferente, %edi (ou uma de suas partes) \u00e9 sempre o primeiro par\u00e2metro. Exercise A instru\u00e7\u00e3o call realiza chamadas de fun\u00e7\u00e3o. Traduza a chamada de fun\u00e7\u00e3o acima para C . Answer exemplo1(1, 2, 3, 4, 5, 6) Vamos agora analisar o c\u00f3digo de exemplo1 : Dump of assembler code for function exemplo1 : 0 x01149 <+ 0 > : endbr64 0x0114d <+ 4 > : add %esi , %edi 0 x0114f <+ 6 > : add %edx , %edi 0 x01151 <+ 8 > : add %ecx , %edi 0 x01153 <+ 10 > : add %r8d , %edi 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax 0 x0115a <+ 17 > : ret Exercise Quantos par\u00e2metros a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Ela retorna algum valor? Se sim, qual seu tipo? Answer Pelos registradores utilizados, percebemos que a fun\u00e7\u00e3o tem seis par\u00e2metros, todos int . O retorno tamb\u00e9m \u00e9 int . Exercise Declare a fun\u00e7\u00e3o acima com base na sua resposta anterior. Answer int exemplo1(int a, int b, int c, int d, int e, int f); Exercise O que faz o conjunto de instru\u00e7\u00f5es add nas linhas +4 at\u00e9 +10 ? Escreva uma express\u00e3o em C equivalente. Answer Ela soma os primeiros 5 argumentos: a + b + c + e . Vemos na linha exemplo1+13 que colocamos um valor no registrador %eax e depois finalizamos a fun\u00e7\u00e3o usando ret . Este \u00e9 o segundo ponto que nunca muda: o valor de retorno de toda fun\u00e7\u00e3o \u00e9 colocado no registrador %rax (ou uma de suas partes menores). Neste exemplo, a instru\u00e7\u00e3o usada foi o LEA que relembraremos na se\u00e7\u00e3o a seguir.","title":"Chamadas de fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#operacoes-aritmeticas-usando-lea","text":"Se usada de maneira literal, a instru\u00e7\u00e3o LEA (Load Effective Address) serve para calcular o endere\u00e7o de uma vari\u00e1vel local e \u00e9 equivalente ao operador & em C . Por\u00e9m, ela \u00e9 frequentemente \"abusada\" para fazer aritm\u00e9tica. Um ponto importante quando usamos LEA \u00e9 que todos os operandos s\u00e3o registradores de 64 bits. Regra geral Se LEA for usada com o registrador %rsp ent\u00e3o ela sempre representa o operador & Se os registradores envolvidos foram usados como n\u00fameros inteiros em instru\u00e7\u00f5es anteriores, ent\u00e3o ela representa uma conta com os valores dos registradores. Vejamos o exemplo da fun\u00e7\u00e3o exemplo1 acima: lea ( %rdi , %r9 , 1 ), %eax 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax No exemplo acima LEA \u00e9 usada para fazer aritm\u00e9tica. Sabemos disso pois, na chamada traduzida na parte anterior, elas recebem n\u00fameros inteiros ( %r9d = 6 e %edi = 1 mais o resultado de sucessivas somas). Seu primeiro argumento segue a seguinte l\u00f3gica C ( %R1 , %R2 , S ) C \u00e9 uma constante %R1 \u00e9 um registrador %R2 \u00e9 um registrador (pode ser igual a %R1 ) S \u00e9 1, 2, 4 ou 8 (todos os tamanhos poss\u00edveis de registradores inteiros) A opera\u00e7\u00e3o acima calcula C + %R1 + (%R2 * S) . A opera\u00e7\u00e3o LEA nunca acessa a mem\u00f3ria , apenas move o resultado deste c\u00e1lculo para o registrador destino. Qualquer outra opera\u00e7\u00e3o que use a sintaxe acima est\u00e1 fazendo um acesso a mem\u00f3ria. LEA \u00e9 a \u00fanica exce\u00e7\u00e3o! Exercise Traduza a opera\u00e7\u00e3o abaixo para C 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax Answer Supondo que aux = a+b+c+d+e j\u00e1 foi calculado com o uso das instru\u00e7\u00f5es ADD , ent\u00e3o o LEA calcula aux + f*1 . Exercise Com estas informa\u00e7\u00f5es em m\u00e3os, traduza exemplo1 para C Dump of assembler code for function exemplo1 : 0 x01149 <+ 0 > : endbr64 0x0114d <+ 4 > : add %esi , %edi 0 x0114f <+ 6 > : add %edx , %edi 0 x01151 <+ 8 > : add %ecx , %edi 0 x01153 <+ 10 > : add %r8d , %edi 0 x01156 <+ 13 > : lea ( %rdi , %r9 , 1 ), %eax 0 x0115a <+ 17 > : ret Answer Confira no arquivo exemplo1.c","title":"Opera\u00e7\u00f5es aritm\u00e9ticas usando LEA"},{"location":"aulas/06-condicionais-funcoes/#retorno-de-funcoes","text":"Vamos terminar nossa revis\u00e3o analisando novamente a chamada de exemplo1 no main : 0 x01163 <+ 8 > : mov $0x6 , %r9d 0 x01169 <+ 14 > : mov $0x5 , %r8d 0 x0116f <+ 20 > : mov $0x4 , %ecx 0 x01174 <+ 25 > : mov $0x3 , %edx 0 x01179 <+ 30 > : mov $0x2 , %esi 0 x0117e <+ 35 > : mov $0x1 , %edi 0 x01183 <+ 40 > : call 0x1149 < exemplo1 > 0 x01188 <+ 45 > : lea 0xa ( %rax ), %esi Anteriormente j\u00e1 vimos que o call e os mov s acima fazem a chamada exemplo1(1,2,3,4,5,6) em C . A linha de baixo realiza uma opera\u00e7\u00e3o aritm\u00e9tica com %rax . Exercise Considerando que %rax armazena o valor de retorno de uma fun\u00e7\u00e3o, qual seria a tradu\u00e7\u00e3o para C do bloco de c\u00f3digo acima? Answer int esi = exemplo1(1, 2, 3, 4, 5, 6) + 10;","title":"Retorno de fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#exercicios-combinados","text":"Warning Todos os exerc\u00edcios desta se\u00e7\u00e3o s\u00e3o para entrega. Voc\u00eas podem se conversar para faz\u00ea-los, mas cada um deve criar sua pr\u00f3pria solu\u00e7\u00e3o do zero. Todos os exerc\u00edcios j\u00e1 est\u00e3o dispon\u00edveis no seu reposit\u00f3rio de entregas da disciplina em atv/04-condicionais-funcoes . Leia o README dentro da pasta para mais informa\u00e7\u00f5es.","title":"Exerc\u00edcios combinados"},{"location":"aulas/06-condicionais-funcoes/#funcao-ex1-aritmetica-e-expressoes-booleanas","text":"Dump of assembler code for function ex1 : 0 x000 <+ 0 > : endbr64 0 x004 <+ 4 > : lea ( %rdi , %rsi , 1 ), %rax 0 x008 <+ 8 > : lea ( %rax , %rdx , 4 ), %rcx 0 x00c <+ 12 > : imul %rdi , %rdi 0 x010 <+ 16 > : lea ( %rdi , %rsi , 2 ), %rax 0 x014 <+ 20 > : add %rax , %rdx 0 x017 <+ 23 > : cmp %rdx , %rcx 0 x01a <+ 26 > : setge %al 0 x01d <+ 29 > : movzbl %al , %eax 0 x020 <+ 32 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Declare a fun\u00e7\u00e3o abaixo. Exercise As instru\u00e7\u00f5es LEA acima representam opera\u00e7\u00f5es aritm\u00e9ticas ou a opera\u00e7\u00e3o endere\u00e7o de & ? Como voc\u00ea fez esta identifica\u00e7\u00e3o? . Exercise Traduza as opera\u00e7\u00f5es das linhas ex1+0 at\u00e9 ex1+16 para C Exercise Nas linhas ex1+23 e ex1+26 \u00e9 feita uma compara\u00e7\u00e3o. Qual e entre quais registradores? Onde \u00e9 armazenado este resultado? Exercise O qu\u00ea faz a instru\u00e7\u00e3o movzbl em ex1+29 ? Juntando com a resposta da pergunta acima, traduza as instru\u00e7\u00f5es ex1+23 at\u00e9 ex1+32 para C . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"Fun\u00e7\u00e3o ex1: Aritm\u00e9tica e Express\u00f5es booleanas."},{"location":"aulas/06-condicionais-funcoes/#funcao-ex2-chamadas-de-funcoes-e-condicionais","text":"Quando analisar o c\u00f3digo do ex2 no gdb, utilize o arquivo ex2_ref para visualizar corretamente as chamadas de fun\u00e7\u00f5es. Seria uma boa tamb\u00e9m consultar as relocation entries no terminal com objdump -r ex2.o . Dump of assembler code for function ex2 : 0 x01132 <+ 0 > : endbr64 0 x01136 <+ 4 > : push %rbx 0 x01137 <+ 5 > : mov %rdi , %rbx 0 x0113a <+ 8 > : mov %rsi , %rdi 0 x0113d <+ 11 > : call 0x1129 < vezes2 > 0 x01142 <+ 16 > : cmp %rbx , %rax 0 x01145 <+ 19 > : jle 0x114a < ex2 + 24 > 0 x01147 <+ 21 > : add %rbx , %rbx 0 x0114a <+ 24 > : add %rbx , %rax 0 x0114d <+ 27 > : pop %rbx 0 x0114e <+ 28 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais s\u00e3o seus tipos? Declare-a abaixo. Vamos come\u00e7ar trabalhando na linha ex2+11 , na instru\u00e7\u00e3o call vezes2 . A chamada necessita usar o registrador %rdi , mas ele cont\u00e9m o primeiro argumento de ex2 . Exercise Em qual registrador \u00e9 guardado o primeiro argumento de ex2 ? Isso \u00e9 feito antes da chamada call . Exercise Qual vari\u00e1vel \u00e9 passada como argumento para a fun\u00e7\u00e3o vezes2 ? Exercise Escreva abaixo a invoca\u00e7\u00e3o de vezes2 . Voc\u00ea deve ter notado as instru\u00e7\u00f5es push/pop %rbx no come\u00e7o/fim da fun\u00e7\u00e3o. Toda fun\u00e7\u00e3o pode usar os registradores de argumentos (vistos na parte 1) e o de valor de retorno como quiserem. Se precisarem mexer nos outros registradores a pr\u00e1tica \u00e9 salv\u00e1-los na pilha no come\u00e7o da fun\u00e7\u00e3o e restaur\u00e1-los no fim. Assim n\u00e3o importa o que a fun\u00e7\u00e3o fa\u00e7a, para a fun\u00e7\u00e3o chamadora \u00e9 como se n\u00e3o houvesse havido nenhuma modifica\u00e7\u00e3o nos outros registradores. Vamos agora olhar a condicional na linha ex2+16 . Exercise Ap\u00f3s a chamada call , qual o conte\u00fado de %rax ? Exercise Juntando suas respostas nas quest\u00f5es de cima, qual \u00e9 a compara\u00e7\u00e3o feita nas linhas ex2+16, ex2+19 ? Exercise Com essas informa\u00e7\u00f5es em m\u00e3os, fa\u00e7a uma tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if+goto . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"Fun\u00e7\u00e3o ex2: Chamadas de fun\u00e7\u00f5es e Condicionais."},{"location":"aulas/06-condicionais-funcoes/#funcao-ex3-ponteiros-e-expressoes-booleanas","text":"Dump of assembler code for function ex3 : 0 x000 <+ 0 > : endbr64 0 x004 <+ 4 > : cmp %rsi , %rdi 0 x007 <+ 7 > : setl %al 0 x00a <+ 10 > : movzbl %al , %eax 0 x00d <+ 13 > : mov %eax ,( %rdx ) 0 x00f <+ 15 > : sete %al 0 x012 <+ 18 > : movzbl %al , %eax 0 x015 <+ 21 > : mov %eax ,( %rcx ) 0 x017 <+ 23 > : setg %al 0 x01a <+ 26 > : movzbl %al , %eax 0 x01d <+ 29 > : mov %eax ,( %r8 ) 0 x020 <+ 32 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? De quais tipos? Declare-a abaixo. Exercise A fun\u00e7\u00e3o acima faz v\u00e1rias compara\u00e7\u00f5es. Liste quais e entre quais argumentos. Exercise Onde \u00e9 armazenado o resultado de cada compara\u00e7\u00e3o? Exercise Com base em suas respostas acima, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha da fun\u00e7\u00e3o acima. Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"Fun\u00e7\u00e3o ex3: Ponteiros e Express\u00f5es booleanas."},{"location":"aulas/06-condicionais-funcoes/#funcao-ex4-ponteiros-e-expressoes-booleanas","text":"Dump of assembler code for function ex4 : 0 x00a <+ 0 > : endbr64 0x00e <+ 4 > : cmp $0x11 , %di 0 x012 <+ 8 > : jle 0x21 < ex4 + 23 > 0 x014 <+ 10 > : sub $0x41 , %esi 0 x017 <+ 13 > : cmp $0x1 , %sil 0 x01b <+ 17 > : ja 0x29 < ex4 + 31 > 0 x01d <+ 19 > : lea -0 x11 ( %rdi ), %eax 0 x020 <+ 22 > : ret 0x021 <+ 23 > : mov $0x12 , %eax 0 x026 <+ 28 > : sub %edi , %eax 0 x028 <+ 30 > : ret 0x029 <+ 31 > : mov $0xffffffff , %eax 0 x02e <+ 36 > : ret Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? De quais tipos? Declare-a abaixo. Exercise A fun\u00e7\u00e3o acima faz v\u00e1rias compara\u00e7\u00f5es. Liste quais e entre quais argumentos. Exercise Onde \u00e9 armazenado o resultado de cada compara\u00e7\u00e3o? Exercise Com base em suas respostas acima, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha da fun\u00e7\u00e3o acima. Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"Fun\u00e7\u00e3o ex4: Ponteiros e Express\u00f5es booleanas."},{"location":"labs/hackerlab/","text":"Hackerlab \u00b6 Introdu\u00e7\u00e3o \u00b6 O prop\u00f3sito desta atividade \u00e9 torn\u00e1-los proficientes na engenharia reversa de execut\u00e1veis . Cada um de voc\u00eas recebeu um execut\u00e1vel app que pede uma s\u00e9rie de senhas para ser desativado. Estas senhas devem ser descobertas atrav\u00e9s da an\u00e1lise do c\u00f3digo Assembly do execut\u00e1vel. Onde trabalhar? \u00b6 O seu execut\u00e1vel app foi deixado no seu reposit\u00f3rio de entregas da disciplina na pasta lab/01-hackerlab . Ao execut\u00e1-lo, confira se o seu nome \u00e9 a primeira sa\u00edda. Em caso negativo, entre em contato com o professor imediatamente. Como trabalhar? \u00b6 Execute o app . Ser\u00e1 apresentado seu nome. Ent\u00e3o, o programa ir\u00e1 esperar uma entrada, que \u00e9 uma senha que destrava o level 1. $ ./app MACIEL Level1: Para descrobrir a senha, voc\u00ea ter\u00e1 que abrir o gdb no gdb e fazer engenharia reversa para entender seu c\u00f3digo. Quando voc\u00ea tiver descoberto uma senha que destrava o n\u00edvel, teste se funciona! Vamos supor que voc\u00ea desconfia que a senha seja lasanha . $ ./app MACIEL Level1:lasanha Nao foi desta vez! Como podemos ver, lasanha n\u00e3o \u00e9 uma senha correta para o n\u00edvel 1! Conforme for descobrindo, voc\u00ea dever\u00e1 editar um arquivo solucao.txt contendo as senhas usadas para desativar cada n\u00edvel. Cada senha dever\u00e1 estar em uma linha. O arquivo entregue deve funcionar como entrada para liberar acesso \u00e0 aplica\u00e7\u00e3o! $ ./app < solucao.txt Aten\u00e7\u00e3o! O arquivo deve se chamar solucao.txt , ser editado no Linux e codificado como UTF-8. Como entregar? \u00b6 Para que sua solu\u00e7\u00e3o seja considerada pelo servidor de corre\u00e7\u00e3o, ap\u00f3s subir suas altera\u00e7\u00f5es para o github, fa\u00e7a uma tag com o padr\u00e3o de nomenclatura lab1.x.y , substituindo x e y por qualquer n\u00famero inteiro! Ex: $ git tag -a lab1.0.1 -m \"lab1.0.1\" $ git push origin lab1.0.1 Entregas cont\u00ednuas! N\u00e3o deixe para entregar no \u00faltimo minuto, fa\u00e7a entregas cont\u00ednuas conforme for evoluindo nos n\u00edveis! Al\u00e9m disso, comece logo . O lab foi pensado para ser feito conforme os conte\u00fados s\u00e3o apresentados. Certamente ter\u00e1 dificuldades se deixar para os \u00faltimos dias! Como serei avaliado? \u00b6 S\u00e3o dez n\u00edveis e cada um vale 1,0 de nota. Sua solu\u00e7\u00e3o conseguir\u00e1 ficar com status pass apenas quando conseguir passar em todos os n\u00edveis, entretanto, mesmo com fail a nota parcial ser\u00e1 considerada. Qual o prazo? \u00b6 Veja mais em https://insper.github.io/SistemasHardwareSoftware/sobre/","title":"Hackerlab"},{"location":"labs/hackerlab/#hackerlab","text":"","title":"Hackerlab"},{"location":"labs/hackerlab/#introducao","text":"O prop\u00f3sito desta atividade \u00e9 torn\u00e1-los proficientes na engenharia reversa de execut\u00e1veis . Cada um de voc\u00eas recebeu um execut\u00e1vel app que pede uma s\u00e9rie de senhas para ser desativado. Estas senhas devem ser descobertas atrav\u00e9s da an\u00e1lise do c\u00f3digo Assembly do execut\u00e1vel.","title":"Introdu\u00e7\u00e3o"},{"location":"labs/hackerlab/#onde-trabalhar","text":"O seu execut\u00e1vel app foi deixado no seu reposit\u00f3rio de entregas da disciplina na pasta lab/01-hackerlab . Ao execut\u00e1-lo, confira se o seu nome \u00e9 a primeira sa\u00edda. Em caso negativo, entre em contato com o professor imediatamente.","title":"Onde trabalhar?"},{"location":"labs/hackerlab/#como-trabalhar","text":"Execute o app . Ser\u00e1 apresentado seu nome. Ent\u00e3o, o programa ir\u00e1 esperar uma entrada, que \u00e9 uma senha que destrava o level 1. $ ./app MACIEL Level1: Para descrobrir a senha, voc\u00ea ter\u00e1 que abrir o gdb no gdb e fazer engenharia reversa para entender seu c\u00f3digo. Quando voc\u00ea tiver descoberto uma senha que destrava o n\u00edvel, teste se funciona! Vamos supor que voc\u00ea desconfia que a senha seja lasanha . $ ./app MACIEL Level1:lasanha Nao foi desta vez! Como podemos ver, lasanha n\u00e3o \u00e9 uma senha correta para o n\u00edvel 1! Conforme for descobrindo, voc\u00ea dever\u00e1 editar um arquivo solucao.txt contendo as senhas usadas para desativar cada n\u00edvel. Cada senha dever\u00e1 estar em uma linha. O arquivo entregue deve funcionar como entrada para liberar acesso \u00e0 aplica\u00e7\u00e3o! $ ./app < solucao.txt Aten\u00e7\u00e3o! O arquivo deve se chamar solucao.txt , ser editado no Linux e codificado como UTF-8.","title":"Como trabalhar?"},{"location":"labs/hackerlab/#como-entregar","text":"Para que sua solu\u00e7\u00e3o seja considerada pelo servidor de corre\u00e7\u00e3o, ap\u00f3s subir suas altera\u00e7\u00f5es para o github, fa\u00e7a uma tag com o padr\u00e3o de nomenclatura lab1.x.y , substituindo x e y por qualquer n\u00famero inteiro! Ex: $ git tag -a lab1.0.1 -m \"lab1.0.1\" $ git push origin lab1.0.1 Entregas cont\u00ednuas! N\u00e3o deixe para entregar no \u00faltimo minuto, fa\u00e7a entregas cont\u00ednuas conforme for evoluindo nos n\u00edveis! Al\u00e9m disso, comece logo . O lab foi pensado para ser feito conforme os conte\u00fados s\u00e3o apresentados. Certamente ter\u00e1 dificuldades se deixar para os \u00faltimos dias!","title":"Como entregar?"},{"location":"labs/hackerlab/#como-serei-avaliado","text":"S\u00e3o dez n\u00edveis e cada um vale 1,0 de nota. Sua solu\u00e7\u00e3o conseguir\u00e1 ficar com status pass apenas quando conseguir passar em todos os n\u00edveis, entretanto, mesmo com fail a nota parcial ser\u00e1 considerada.","title":"Como serei avaliado?"},{"location":"labs/hackerlab/#qual-o-prazo","text":"Veja mais em https://insper.github.io/SistemasHardwareSoftware/sobre/","title":"Qual o prazo?"},{"location":"labs/processos/","text":"Inspercoin \u00b6 Introdu\u00e7\u00e3o \u00b6 No Laborat\u00f3rio de Processos, iremos implementar uma blockchain da nossa pr\u00f3pria cryptomoeda: a Inspercoin ! Blockchain \u00e9 uma tecnologia que permite a cria\u00e7\u00e3o de registros digitais seguros, transparentes e imut\u00e1veis. Essa tecnologia funciona como um livro-caixa descentralizado e distribu\u00eddo, onde cada transa\u00e7\u00e3o \u00e9 registrada em blocos de informa\u00e7\u00f5es interligados. Cada bloco cont\u00e9m uma s\u00e9rie de transa\u00e7\u00f5es v\u00e1lidas, incluindo informa\u00e7\u00f5es sobre o remetente, destinat\u00e1rio, data e hor\u00e1rio da transa\u00e7\u00e3o, entre outros dados relevantes. Em uma blockchain h\u00e1 uma rede de computadores interligados que validam as transa\u00e7\u00f5es de forma colaborativa. Dessa forma, todas as informa\u00e7\u00f5es s\u00e3o armazenadas em v\u00e1rios pontos da rede, garantindo maior seguran\u00e7a e confiabilidade. Por fim, vale ressaltar que a criptografia \u00e9 outro elemento fundamental no funcionamento do blockchain. Ela garante a prote\u00e7\u00e3o dos dados e impede que informa\u00e7\u00f5es sens\u00edveis sejam acessadas por pessoas n\u00e3o autorizadas. Al\u00e9m disso, a criptografia tamb\u00e9m torna mais dif\u00edcil a realiza\u00e7\u00e3o de fraudes, j\u00e1 que alterar dados em um bloco exige muito poder computacional e seria rapidamente identificado pela rede. Em resumo, o blockchain \u00e9 uma tecnologia revolucion\u00e1ria capaz de transformar diversos setores da economia, oferecendo maior seguran\u00e7a e transpar\u00eancia \u00e0s transa\u00e7\u00f5es. Entendendo como uma blockchain funciona \u00b6 Para entender como uma blockchain funciona, precisamos revisar alguns conceitos. Hash \u00b6 Um hash \u00e9 uma fun\u00e7\u00e3o matem\u00e1tica que transforma dados de tamanho vari\u00e1vel em um valor fixo de comprimento menor. Essa transforma\u00e7\u00e3o \u00e9 f\u00e1cil de fazer na ida (f\u00e1cil de calcular o hash a partir de uma mensagem original) mas muito dif\u00edcil ou imposs\u00edvel de obter com certeza os dados originais a partir do valor hash . Isso faz com que o hash seja muito utilizado em sistemas de seguran\u00e7a. Acesse https://andersbrownworth.com/blockchain/hash e digite algum texto. Voc\u00ea ver\u00e1 o hash sendo calculado em tempo real. Bloco \u00b6 Um bloco \u00e9 uma unidade b\u00e1sica de armazenamento de dados de uma blockchain. Cada bloco cont\u00e9m um conjunto de mensagens armazenadas. No nosso caso, ao inv\u00e9s de armazenar mensagens de conversa\u00e7\u00e3o, a nossa mensagem conter\u00e1 os dados de uma transa\u00e7\u00e3o financeira da Inspercoin: Origem dos recursos Destino dos recursos Valor a ser transferido Data da transa\u00e7\u00e3o Etc. Minerar um Bloco \u00b6 O Bloco n\u00e3o deve depender de uma autoridade central para validar as transa\u00e7\u00f5es. Em nosso caso, o processo de valida\u00e7\u00e3o envolve a resolu\u00e7\u00e3o de um problema matem\u00e1tico conhecido como prova de trabalho (PoW). Ao concatenar as informa\u00e7\u00f5es da mensagem ou dados do bloco com as informa\u00e7\u00f5es do bloco (por exemplo, seu ID ou n\u00famero), podemos calcular seu hash . Minerar ou validar um bloco envolver\u00e1 concatenar este texto anterior com algum ru\u00eddo aleat\u00f3rio ( nonce ) e recalcular o hash at\u00e9 que seja obtido um hash com um n\u00famero m\u00ednimo de zeros no seu inicio. A quantidade de zeros especifica o n\u00edvel de dificuldade da rede, quanto mais zeros, \u00e9 esperado que mais tempo/poder computacional seja utilizado para minerar o bloco. Quando um bloco \u00e9 validado, ele \u00e9 adicionado \u00e0 blockchain e torna-se parte do hist\u00f3rico de transa\u00e7\u00f5es registrado na blockchain. Blockchain \u00b6 De posse dos blocos, para formar a blockchain basta vincular cada bloco ao bloco imediatamente anterior. Ent\u00e3o, cada bloco guarda o hash do bloco anterior . Al\u00e9m disso, o primeiro bloco \u00e9 conhecido como Genesis Block . Lembre-se que encontrar o nonce para que o hash tenha o n\u00famero requisitado de zeros \u00e9 algo complicado. Ent\u00e3o, neste caso a PoW garante a seguran\u00e7a da rede, pois seria custoso computacionalmente recalcular blocos antigos (para mudar os valores aceitos pela rede). Assim, nossos blocos permanecem entrela\u00e7ados. Um passo importante ser\u00e1 fazer o broadcasting do bloco rec\u00e9m minerado, pois n\u00e3o basta apenas voc\u00ea \"acreditar\" neste bloco! Gastando a Grana! \u00b6 J\u00e1 discutimos brevemente que iremos armazenar os dados da transa\u00e7\u00e3o na mensagem do bloco. Uma quest\u00e3o importante \u00e9: Como representamos \"contas\"? \u00b6 Iremos utilizar \"endere\u00e7os\". Em nosso desenho, um endere\u00e7o ser\u00e1 uma string de 64 caracteres hexadecimais (cada posi\u00e7\u00e3o tem de 0..9A..F ). Como garanto que a transa\u00e7\u00e3o \u00e9 v\u00e1lida? \u00b6 Aqui, uma distin\u00e7\u00e3o precisa ficar clara. Minerar um bloco envolve encontrar o nonce que, concatenado \u00e0s demais informa\u00e7\u00f5es do bloco, gera um hash com um determinado n\u00famero de zeros em seu in\u00edcio. Por\u00e9m, o que ir\u00e1 impedir do conte\u00fado da mensagem ou transa\u00e7\u00e3o (dados armazenados no bloco) ser inv\u00e1lido? Por exemplo, imagine a transa\u00e7\u00e3o que diz \"transfira 100 reais do jo\u00e3o para o jos\u00e9\" . A transa\u00e7\u00e3o s\u00f3 ser\u00e1 v\u00e1lida se: Jo\u00e3o tiver saldo suficiente . Precisamos prevenir gasto duplo (sai mais dinheiro que o que entrou no endere\u00e7o). Soubermos de fato que \u00e9 realmente o Jo\u00e3o a fazer a transfer\u00eancia. O primeiro problema ser\u00e1 abordado pela pr\u00f3pria natureza global e entrela\u00e7ada da blockchain. Pelo hist\u00f3rico de transa\u00e7\u00f5es, podemos verificar o saldo dos endere\u00e7os e rejeitar blocos com transa\u00e7\u00f5es sem saldo (endere\u00e7os de origem sem saldo). O segundo problema \u00e9 resolvido pelo uso de uma t\u00e9cnica de criptografia: chave p\u00fablica e privada. O emissor ir\u00e1 utilizar uma chave privada (guardada apenas para si pr\u00f3prio) para assinar a transa\u00e7\u00e3o. A assinatura ser\u00e1 uma string a ser enviada junto com a transa\u00e7\u00e3o. Conhecendo os dados da transa\u00e7\u00e3o (a mensagem a ser assinada), a assinatura e a chave p\u00fablica , podemos verificar matematicamente que a transa\u00e7\u00e3o foi de fato assinada pelo propriet\u00e1rio da chave privada sem ter acesso \u00e0 ela ! Novamente, ser\u00e1 computacionalmente f\u00e1cil validar a assinatura, mas computacionalmente dif\u00edcil descobrir a chave privada! Para saber mais, acesse https://auth0.com/blog/how-to-explain-public-key-cryptography-digital-signatures-to-anyone/ Off-Topic: chaves com baixa entropia \u00b6 N\u00e3o \u00e9 s\u00f3 porque foi gerado um bando de hexas aleat\u00f3rios que parecem indecifr\u00e1veis que a chave \u00e9 segura. Para ser de fato segura, suas chaves precisam ter alta entropia. Para entenderem o conceito, abra o site https://andersbrownworth.com/blockchain/hash e digite \" super mario bros \". Se as chaves dependem de nomes de filmes, atores, m\u00fasicos ou datas, uma hacker espertinho poderia testar por for\u00e7a bruta estas combina\u00e7\u00f5es mais f\u00e1ceis de adivinhar, ent\u00e3o n\u00e3o ser\u00e1 muito dif\u00edcil descobrir as suas senhas (incluindo super mario bros ). Leia mais em https://blog.mycrypto.com/your-crypto-wouldnt-be-secure-without-entropy e https://www.wired.com/story/blockchain-bandit-ethereum-weak-private-keys/ O que precisar\u00e1 ser feito \u00b6 Voc\u00ea precisar\u00e1 implementar em C um aplicativo que consegue minerar inspercoin e gerar transa\u00e7\u00f5es. Ser\u00e1 disponibilizado um c\u00f3digo b\u00e1sico que dever\u00e1 ser personalizado. Considere que cada bloco da Inspercoin armazena apenas uma transa\u00e7\u00e3o. Para manter um maior controle no escopo da atividade, implementamos uma API que far\u00e1 a intermedia\u00e7\u00e3o entre os mineradores. Voc\u00eas ter\u00e3o que consumir a API para requisitar informa\u00e7\u00f5es sobre transa\u00e7\u00f5es, blocos, dificuldade, etc. Veja a documenta\u00e7\u00e3o das rotas em http://sishard.insper-comp.com.br/inspercoin/docs Onde desenvolver? \u00b6 Foi criado uma pasta lab/02-inspercoin em seu reposit\u00f3rio de entregas da disciplina. Edite o arquivo inspercoin.c e comece! Para compilar, utilize obrigatoriamente: $ make rebuild Como come\u00e7ar? \u00b6 Fa\u00e7a git pull no seu reposit\u00f3rio de atividades e leia o README.md na pasta do lab. Ainda, copie c\u00f3digos deste reposit\u00f3rio https://github.com/macielcalebe/inspercoin e implemente as fun\u00e7\u00f5es faltantes (caso queira, pode copiar todos os arquivos para dentro da sua pasta do lab). N\u00e3o precisa come\u00e7ar do zero! Avalia\u00e7\u00e3o \u00b6 O programa ser\u00e1 avaliado usando uma rubrica que descreve as funcionalidades implementadas. Quanto maior o n\u00famero de funcionalidades, maior ser\u00e1 a nota. Apesar de cada conceito envolver a entrega de uma tag no servidor de testes, a nota final da atividade ser\u00e1 o maior conceito implementado, considerando que passou em todos os anteriores . Ex: Se passar na lab2.0.x , n\u00e3o passar na lab2.1.x , passar na lab2.2.x , n\u00e3o passar na lab2.3.x a nota final ser\u00e1 a da lab2.0.x . Aten\u00e7\u00e3o: Os testes autom\u00e1ticos ser\u00e3o nossa forma principal de avalia\u00e7\u00e3o. Entretanto, o professor poder\u00e1 utilizar processos extras de avalia\u00e7\u00e3o, como: entrevistas, revis\u00e3o manual de c\u00f3digo. Vers\u00f5es a serem entregues \u00b6 Entregue cada vers\u00e3o utilizando o padr\u00e3o j\u00e1 conhecido. Exemplo da vers\u00e3o lab2.0.x : $ git tag -a lab2.0.55 -m \"lab2.0.55\" $ git push origin lab2.0.55 Segue lista de vers\u00f5es. Tag lab2.0.x : Vers\u00e3o Iniciante \u00b6 O programa l\u00ea um arquivo de texto config.ic na raiz do reposit\u00f3rio, que cont\u00e9m as vari\u00e1veis de ambiente a serem utilizadas pelo programa em execu\u00e7\u00e3o. Exemplo de conte\u00fado do arquivo: INSPER_COIN_URL=http://sishard.insper-comp.com.br/inspercoin/ DEFAULT_WALLET=to_rico Conforme o exemplo, todas as chamadas de API devem ser feitas a partir desta origem contida em INSPER_COIN_URL . Ent\u00e3o, para ler a blockchain, o programa deve automaticamente utilizar: http://sishard.insper-comp.com.br/inspercoin/blockchain Para testar, utilizem estas poss\u00edveis APIs como INSPER_COIN_URL : http://sishard.insper-comp.com.br/inspercoin/ http://sishard.insper-comp.com.br/lubacoin/ http://sishard.insper-comp.com.br/lc/ http://sishard.insper-comp.com.br/menezescoin/ http://sishard.insper-comp.com.br/inspercoin_so_que_com_url_grande/ http://3.142.157.80/inspercoin/ http://3.142.157.80/lubacoin/ http://3.142.157.80/lc/ http://3.142.157.80/menezescoin/ http://3.142.157.80/inspercoin_so_que_com_url_grande/ Se quiser fazer testes (ex: ver a blockchain), todas tem a rota /docs para abrir no navegador: http://sishard.insper-comp.com.br/inspercoin/docs http://sishard.insper-comp.com.br/lubacoin/docs http://sishard.insper-comp.com.br/menezescoin/docs As duas \u00faltimas funcionam como forks da blockchain, ou seja, cada uma ser\u00e1 uma blockchain diferente ap\u00f3s o bloco g\u00eanesis. O programa pode ser chamado pela linha de comando, utilizando as seguintes sintaxes: ./inspercoin criar carteira <nome> ./inspercoin enviar <valor> da carteira <carteira> para endereco <chave_publica_destino> com recompensa <valor_recompensa> Requisitos: No arquivo config.ic , a chave DEFAULT_WALLET poder\u00e1 estar em qualquer linha, o mesmo para INSPER_COIN_URL . Cada linha sempre come\u00e7a com o nome da vari\u00e1vel de ambiente (n\u00e3o conter\u00e1 espa\u00e7os), seguida por um igual (sem espa\u00e7os antes ou depois), seguida pelo valor da vari\u00e1vel (que tamb\u00e9m n\u00e3o conter\u00e1 espa\u00e7os). Em ./inspercoin criar carteira <nome> o programa deve criar dois arquivos ( <nome>.private contendo a chave privada em uma string de 128 hexa e <nome>.public contendo uma chave de 64 hexa). Nota que as chaves p\u00fablicas \u00e9 que ir\u00e3o servir de endere\u00e7o de origem e destino nas transa\u00e7\u00f5es. Este c\u00f3digo est\u00e1 pronto, garanta que continua funcionando! Em ./inspercoin enviar <valor> da carteira <carteira> para endereco <chave_publica_destino> com recompensa <valor_recompensa> o programa l\u00ea a carteira, usa a chave privada para assinar a transa\u00e7\u00e3o e a chave p\u00fablica como origem do montante! Esta chamada est\u00e1 praticamente pronta, bastando alterar a URL da API para ser lida do arquivo de configura\u00e7\u00e3o. Importante: a vari\u00e1vel DEFAULT_WALLET ser\u00e1 utilizada apenas na pr\u00f3xima tag/vers\u00e3o! NOTA desta vers\u00e3o : 2.0 Tag lab2.1.x : Vers\u00e3o Em Desenvolvimento \u00b6 Todas as transa\u00e7\u00f5es sem origem (ex: sem uso do da carteira <endere\u00e7o> ) e de minera\u00e7\u00e3o sem destino devem ser feitas para a carteira padr\u00e3o definida na vari\u00e1vel de ambiente DEFAULT_WALLET da tag anterior (ou seja, ler os arquivos to_rico.private para assinar e to_rico.public para servir como endere\u00e7o de origem/destino). Al\u00e9m dos comandos da vers\u00e3o anterior, o programa pode ser chamado pela linha de comando, utilizando as seguintes sintaxes: ./inspercoin enviar <valor> para endereco <chave_publica_destino> com recompensa <valor_recompensa> ./inspercoin minear transacao na carteira <carteira> ./inspercoin minear transacao Requisitos: Em ./inspercoin enviar <valor> para endereco <chave_publica_destino> com recompensa <valor_recompensa> note que n\u00e3o foi informado uma carteira. Dever\u00e1 ser utilizada a indicada em DEFAULT_WALLET no config.ic . O mesmo vale para ./inspercoin minear transacao , onde o endere\u00e7o contido na chave p\u00fablica da carteira padr\u00e3o deve ser o endere\u00e7o da recompensa. Em ./inspercoin minear transacao na carteira <carteira> o programa minera uma transa\u00e7\u00e3o, formando um bloco. Caso o programa tente minerar uma transa\u00e7\u00e3o mas falhe (porque outro usu\u00e1rio j\u00e1 minerou e fez broadcast desta transa\u00e7\u00e3o primeiro), ent\u00e3o o programa apenas retorna mensagem adequada de que n\u00e3o foi poss\u00edvel fazer o broadcasting do bloco. Para minerar transa\u00e7\u00f5es, ser\u00e1 preciso corrigir a fun\u00e7\u00e3o miner_address , informando corretamente o endere\u00e7o de destino da recompensa. Al\u00e9m disso, ser\u00e1 preciso corrigir a fun\u00e7\u00e3o get_last_block_hash pois a mesma est\u00e1 retornando sempre zeros, mas ser\u00e1 necess\u00e1rio utilizar as rotas da API para buscar pelo hash do \u00faltimo bloco minerado! NOTA desta vers\u00e3o : 3.5 Tag lab2.2.x : Vers\u00e3o Pleno - Atingiu objetivos m\u00e9dios \u00b6 Al\u00e9m dos comandos da vers\u00e3o anterior, o programa pode ser chamado pela linha de comando, utilizando as seguintes sintaxes: ./inspercoin minear <qtde> transacoes Requisitos: Em ./inspercoin minear <qtde> transacoes o programa cria <qtde> processos que rodam concorrentemente tentando minerar blocos. O programa pai s\u00f3 encerra ap\u00f3s todos os filhos retornarem. Exiba mensagens contendo informa\u00e7\u00f5es sobre blocos minerados com sucesso! NOTA desta vers\u00e3o : 5.0 Tag lab2.3.x : Vers\u00e3o S\u00eanior - Atingiu objetivos avan\u00e7ados \u00b6 Al\u00e9m dos comandos da vers\u00e3o anterior, o programa pode ser chamado pela linha de comando, utilizando as seguintes sintaxes: ./inspercoin minear <qtde_tran> transacoes em <qtde_proc> processos Requisitos: O programa faz requisi\u00e7\u00f5es \u00e0 API e mant\u00e9m em execu\u00e7\u00e3o <qtde_proc> processos rodando concorrentemente minerando transa\u00e7\u00f5es. Se a minera\u00e7\u00e3o de algum bloco falhar porque o bloco foi minerado primeiro por outra pessoa na rede, apenas ignore (n\u00e3o precisa subir nova execu\u00e7\u00e3o). Caso fa\u00e7a uma chamada \u00e0 API e n\u00e3o consiga transa\u00e7\u00f5es suficientes para iniciar pelo menos processos, ignore e suba apenas o que conseguir! Observe que at\u00e9 aqui a API de GET transa\u00e7\u00f5es dever\u00e1 ser chamada apenas uma vez. NOTA desta vers\u00e3o : 8.0 Tag lab2.4.x : Vers\u00e3o Especialista - Demonstra conhecimentos que Superam Expectativas \u00b6 Al\u00e9m dos comandos da vers\u00e3o anterior, o programa pode ser chamado pela linha de comando, utilizando as seguintes sintaxes: ./inspercoin minear em <qtde_proc> processos ./inspercoin minear em <qtde_proc> processos na carteira <carteira> Requisitos: O programa realiza requisi\u00e7\u00f5es de transa\u00e7\u00f5es e mant\u00e9m <qtde_proc> processos rodando concorrentemente tentando minerar transa\u00e7\u00f5es. Aqui, para cada filho que retornar, um novo filho \u00e9 criado para minerar uma transa\u00e7\u00e3o diferente. Caso n\u00e3o existam transa\u00e7\u00f5es, o pai deve tentar subir novamente um filho em 5 segundos (buscar por nova transa\u00e7\u00e3o, iniciando a minera\u00e7\u00e3o no filho, caso exista transa\u00e7\u00e3o esperando minera\u00e7\u00e3o). A ideia \u00e9 manter ` processos rodando sempre que poss\u00edvel. Observe que a API de GET transa\u00e7\u00f5es precisar\u00e1 ser chamada m\u00faltiplas vezes. Ao receber CTRL+C, o programa pai encerra todos os filhos e sai com sinal adequado. Ao sair, apenas o programa pai deve exibir a mensagem na sa\u00edda padr\u00e3o Encerrando minera\u00e7\u00e3o!\\n . NOTA desta vers\u00e3o : 10.0 Prazo \u00b6 Clique Aqui Refer\u00eancias \u00b6 Parte do texto foi escrito utilizando https://chatbot.theb.ai/","title":"Inspercoin"},{"location":"labs/processos/#inspercoin","text":"","title":"Inspercoin"},{"location":"labs/processos/#introducao","text":"No Laborat\u00f3rio de Processos, iremos implementar uma blockchain da nossa pr\u00f3pria cryptomoeda: a Inspercoin ! Blockchain \u00e9 uma tecnologia que permite a cria\u00e7\u00e3o de registros digitais seguros, transparentes e imut\u00e1veis. Essa tecnologia funciona como um livro-caixa descentralizado e distribu\u00eddo, onde cada transa\u00e7\u00e3o \u00e9 registrada em blocos de informa\u00e7\u00f5es interligados. Cada bloco cont\u00e9m uma s\u00e9rie de transa\u00e7\u00f5es v\u00e1lidas, incluindo informa\u00e7\u00f5es sobre o remetente, destinat\u00e1rio, data e hor\u00e1rio da transa\u00e7\u00e3o, entre outros dados relevantes. Em uma blockchain h\u00e1 uma rede de computadores interligados que validam as transa\u00e7\u00f5es de forma colaborativa. Dessa forma, todas as informa\u00e7\u00f5es s\u00e3o armazenadas em v\u00e1rios pontos da rede, garantindo maior seguran\u00e7a e confiabilidade. Por fim, vale ressaltar que a criptografia \u00e9 outro elemento fundamental no funcionamento do blockchain. Ela garante a prote\u00e7\u00e3o dos dados e impede que informa\u00e7\u00f5es sens\u00edveis sejam acessadas por pessoas n\u00e3o autorizadas. Al\u00e9m disso, a criptografia tamb\u00e9m torna mais dif\u00edcil a realiza\u00e7\u00e3o de fraudes, j\u00e1 que alterar dados em um bloco exige muito poder computacional e seria rapidamente identificado pela rede. Em resumo, o blockchain \u00e9 uma tecnologia revolucion\u00e1ria capaz de transformar diversos setores da economia, oferecendo maior seguran\u00e7a e transpar\u00eancia \u00e0s transa\u00e7\u00f5es.","title":"Introdu\u00e7\u00e3o"},{"location":"labs/processos/#entendendo-como-uma-blockchain-funciona","text":"Para entender como uma blockchain funciona, precisamos revisar alguns conceitos.","title":"Entendendo como uma blockchain funciona"},{"location":"labs/processos/#hash","text":"Um hash \u00e9 uma fun\u00e7\u00e3o matem\u00e1tica que transforma dados de tamanho vari\u00e1vel em um valor fixo de comprimento menor. Essa transforma\u00e7\u00e3o \u00e9 f\u00e1cil de fazer na ida (f\u00e1cil de calcular o hash a partir de uma mensagem original) mas muito dif\u00edcil ou imposs\u00edvel de obter com certeza os dados originais a partir do valor hash . Isso faz com que o hash seja muito utilizado em sistemas de seguran\u00e7a. Acesse https://andersbrownworth.com/blockchain/hash e digite algum texto. Voc\u00ea ver\u00e1 o hash sendo calculado em tempo real.","title":"Hash"},{"location":"labs/processos/#bloco","text":"Um bloco \u00e9 uma unidade b\u00e1sica de armazenamento de dados de uma blockchain. Cada bloco cont\u00e9m um conjunto de mensagens armazenadas. No nosso caso, ao inv\u00e9s de armazenar mensagens de conversa\u00e7\u00e3o, a nossa mensagem conter\u00e1 os dados de uma transa\u00e7\u00e3o financeira da Inspercoin: Origem dos recursos Destino dos recursos Valor a ser transferido Data da transa\u00e7\u00e3o Etc.","title":"Bloco"},{"location":"labs/processos/#minerar-um-bloco","text":"O Bloco n\u00e3o deve depender de uma autoridade central para validar as transa\u00e7\u00f5es. Em nosso caso, o processo de valida\u00e7\u00e3o envolve a resolu\u00e7\u00e3o de um problema matem\u00e1tico conhecido como prova de trabalho (PoW). Ao concatenar as informa\u00e7\u00f5es da mensagem ou dados do bloco com as informa\u00e7\u00f5es do bloco (por exemplo, seu ID ou n\u00famero), podemos calcular seu hash . Minerar ou validar um bloco envolver\u00e1 concatenar este texto anterior com algum ru\u00eddo aleat\u00f3rio ( nonce ) e recalcular o hash at\u00e9 que seja obtido um hash com um n\u00famero m\u00ednimo de zeros no seu inicio. A quantidade de zeros especifica o n\u00edvel de dificuldade da rede, quanto mais zeros, \u00e9 esperado que mais tempo/poder computacional seja utilizado para minerar o bloco. Quando um bloco \u00e9 validado, ele \u00e9 adicionado \u00e0 blockchain e torna-se parte do hist\u00f3rico de transa\u00e7\u00f5es registrado na blockchain.","title":"Minerar um Bloco"},{"location":"labs/processos/#blockchain","text":"De posse dos blocos, para formar a blockchain basta vincular cada bloco ao bloco imediatamente anterior. Ent\u00e3o, cada bloco guarda o hash do bloco anterior . Al\u00e9m disso, o primeiro bloco \u00e9 conhecido como Genesis Block . Lembre-se que encontrar o nonce para que o hash tenha o n\u00famero requisitado de zeros \u00e9 algo complicado. Ent\u00e3o, neste caso a PoW garante a seguran\u00e7a da rede, pois seria custoso computacionalmente recalcular blocos antigos (para mudar os valores aceitos pela rede). Assim, nossos blocos permanecem entrela\u00e7ados. Um passo importante ser\u00e1 fazer o broadcasting do bloco rec\u00e9m minerado, pois n\u00e3o basta apenas voc\u00ea \"acreditar\" neste bloco!","title":"Blockchain"},{"location":"labs/processos/#gastando-a-grana","text":"J\u00e1 discutimos brevemente que iremos armazenar os dados da transa\u00e7\u00e3o na mensagem do bloco. Uma quest\u00e3o importante \u00e9:","title":"Gastando a Grana!"},{"location":"labs/processos/#como-representamos-contas","text":"Iremos utilizar \"endere\u00e7os\". Em nosso desenho, um endere\u00e7o ser\u00e1 uma string de 64 caracteres hexadecimais (cada posi\u00e7\u00e3o tem de 0..9A..F ).","title":"Como representamos \"contas\"?"},{"location":"labs/processos/#como-garanto-que-a-transacao-e-valida","text":"Aqui, uma distin\u00e7\u00e3o precisa ficar clara. Minerar um bloco envolve encontrar o nonce que, concatenado \u00e0s demais informa\u00e7\u00f5es do bloco, gera um hash com um determinado n\u00famero de zeros em seu in\u00edcio. Por\u00e9m, o que ir\u00e1 impedir do conte\u00fado da mensagem ou transa\u00e7\u00e3o (dados armazenados no bloco) ser inv\u00e1lido? Por exemplo, imagine a transa\u00e7\u00e3o que diz \"transfira 100 reais do jo\u00e3o para o jos\u00e9\" . A transa\u00e7\u00e3o s\u00f3 ser\u00e1 v\u00e1lida se: Jo\u00e3o tiver saldo suficiente . Precisamos prevenir gasto duplo (sai mais dinheiro que o que entrou no endere\u00e7o). Soubermos de fato que \u00e9 realmente o Jo\u00e3o a fazer a transfer\u00eancia. O primeiro problema ser\u00e1 abordado pela pr\u00f3pria natureza global e entrela\u00e7ada da blockchain. Pelo hist\u00f3rico de transa\u00e7\u00f5es, podemos verificar o saldo dos endere\u00e7os e rejeitar blocos com transa\u00e7\u00f5es sem saldo (endere\u00e7os de origem sem saldo). O segundo problema \u00e9 resolvido pelo uso de uma t\u00e9cnica de criptografia: chave p\u00fablica e privada. O emissor ir\u00e1 utilizar uma chave privada (guardada apenas para si pr\u00f3prio) para assinar a transa\u00e7\u00e3o. A assinatura ser\u00e1 uma string a ser enviada junto com a transa\u00e7\u00e3o. Conhecendo os dados da transa\u00e7\u00e3o (a mensagem a ser assinada), a assinatura e a chave p\u00fablica , podemos verificar matematicamente que a transa\u00e7\u00e3o foi de fato assinada pelo propriet\u00e1rio da chave privada sem ter acesso \u00e0 ela ! Novamente, ser\u00e1 computacionalmente f\u00e1cil validar a assinatura, mas computacionalmente dif\u00edcil descobrir a chave privada! Para saber mais, acesse https://auth0.com/blog/how-to-explain-public-key-cryptography-digital-signatures-to-anyone/","title":"Como garanto que a transa\u00e7\u00e3o \u00e9 v\u00e1lida?"},{"location":"labs/processos/#off-topic-chaves-com-baixa-entropia","text":"N\u00e3o \u00e9 s\u00f3 porque foi gerado um bando de hexas aleat\u00f3rios que parecem indecifr\u00e1veis que a chave \u00e9 segura. Para ser de fato segura, suas chaves precisam ter alta entropia. Para entenderem o conceito, abra o site https://andersbrownworth.com/blockchain/hash e digite \" super mario bros \". Se as chaves dependem de nomes de filmes, atores, m\u00fasicos ou datas, uma hacker espertinho poderia testar por for\u00e7a bruta estas combina\u00e7\u00f5es mais f\u00e1ceis de adivinhar, ent\u00e3o n\u00e3o ser\u00e1 muito dif\u00edcil descobrir as suas senhas (incluindo super mario bros ). Leia mais em https://blog.mycrypto.com/your-crypto-wouldnt-be-secure-without-entropy e https://www.wired.com/story/blockchain-bandit-ethereum-weak-private-keys/","title":"Off-Topic: chaves com baixa entropia"},{"location":"labs/processos/#o-que-precisara-ser-feito","text":"Voc\u00ea precisar\u00e1 implementar em C um aplicativo que consegue minerar inspercoin e gerar transa\u00e7\u00f5es. Ser\u00e1 disponibilizado um c\u00f3digo b\u00e1sico que dever\u00e1 ser personalizado. Considere que cada bloco da Inspercoin armazena apenas uma transa\u00e7\u00e3o. Para manter um maior controle no escopo da atividade, implementamos uma API que far\u00e1 a intermedia\u00e7\u00e3o entre os mineradores. Voc\u00eas ter\u00e3o que consumir a API para requisitar informa\u00e7\u00f5es sobre transa\u00e7\u00f5es, blocos, dificuldade, etc. Veja a documenta\u00e7\u00e3o das rotas em http://sishard.insper-comp.com.br/inspercoin/docs","title":"O que precisar\u00e1 ser feito"},{"location":"labs/processos/#onde-desenvolver","text":"Foi criado uma pasta lab/02-inspercoin em seu reposit\u00f3rio de entregas da disciplina. Edite o arquivo inspercoin.c e comece! Para compilar, utilize obrigatoriamente: $ make rebuild","title":"Onde desenvolver?"},{"location":"labs/processos/#como-comecar","text":"Fa\u00e7a git pull no seu reposit\u00f3rio de atividades e leia o README.md na pasta do lab. Ainda, copie c\u00f3digos deste reposit\u00f3rio https://github.com/macielcalebe/inspercoin e implemente as fun\u00e7\u00f5es faltantes (caso queira, pode copiar todos os arquivos para dentro da sua pasta do lab). N\u00e3o precisa come\u00e7ar do zero!","title":"Como come\u00e7ar?"},{"location":"labs/processos/#avaliacao","text":"O programa ser\u00e1 avaliado usando uma rubrica que descreve as funcionalidades implementadas. Quanto maior o n\u00famero de funcionalidades, maior ser\u00e1 a nota. Apesar de cada conceito envolver a entrega de uma tag no servidor de testes, a nota final da atividade ser\u00e1 o maior conceito implementado, considerando que passou em todos os anteriores . Ex: Se passar na lab2.0.x , n\u00e3o passar na lab2.1.x , passar na lab2.2.x , n\u00e3o passar na lab2.3.x a nota final ser\u00e1 a da lab2.0.x . Aten\u00e7\u00e3o: Os testes autom\u00e1ticos ser\u00e3o nossa forma principal de avalia\u00e7\u00e3o. Entretanto, o professor poder\u00e1 utilizar processos extras de avalia\u00e7\u00e3o, como: entrevistas, revis\u00e3o manual de c\u00f3digo.","title":"Avalia\u00e7\u00e3o"},{"location":"labs/processos/#versoes-a-serem-entregues","text":"Entregue cada vers\u00e3o utilizando o padr\u00e3o j\u00e1 conhecido. Exemplo da vers\u00e3o lab2.0.x : $ git tag -a lab2.0.55 -m \"lab2.0.55\" $ git push origin lab2.0.55 Segue lista de vers\u00f5es.","title":"Vers\u00f5es a serem entregues"},{"location":"labs/processos/#tag-lab20x-versao-iniciante","text":"O programa l\u00ea um arquivo de texto config.ic na raiz do reposit\u00f3rio, que cont\u00e9m as vari\u00e1veis de ambiente a serem utilizadas pelo programa em execu\u00e7\u00e3o. Exemplo de conte\u00fado do arquivo: INSPER_COIN_URL=http://sishard.insper-comp.com.br/inspercoin/ DEFAULT_WALLET=to_rico Conforme o exemplo, todas as chamadas de API devem ser feitas a partir desta origem contida em INSPER_COIN_URL . Ent\u00e3o, para ler a blockchain, o programa deve automaticamente utilizar: http://sishard.insper-comp.com.br/inspercoin/blockchain Para testar, utilizem estas poss\u00edveis APIs como INSPER_COIN_URL : http://sishard.insper-comp.com.br/inspercoin/ http://sishard.insper-comp.com.br/lubacoin/ http://sishard.insper-comp.com.br/lc/ http://sishard.insper-comp.com.br/menezescoin/ http://sishard.insper-comp.com.br/inspercoin_so_que_com_url_grande/ http://3.142.157.80/inspercoin/ http://3.142.157.80/lubacoin/ http://3.142.157.80/lc/ http://3.142.157.80/menezescoin/ http://3.142.157.80/inspercoin_so_que_com_url_grande/ Se quiser fazer testes (ex: ver a blockchain), todas tem a rota /docs para abrir no navegador: http://sishard.insper-comp.com.br/inspercoin/docs http://sishard.insper-comp.com.br/lubacoin/docs http://sishard.insper-comp.com.br/menezescoin/docs As duas \u00faltimas funcionam como forks da blockchain, ou seja, cada uma ser\u00e1 uma blockchain diferente ap\u00f3s o bloco g\u00eanesis. O programa pode ser chamado pela linha de comando, utilizando as seguintes sintaxes: ./inspercoin criar carteira <nome> ./inspercoin enviar <valor> da carteira <carteira> para endereco <chave_publica_destino> com recompensa <valor_recompensa> Requisitos: No arquivo config.ic , a chave DEFAULT_WALLET poder\u00e1 estar em qualquer linha, o mesmo para INSPER_COIN_URL . Cada linha sempre come\u00e7a com o nome da vari\u00e1vel de ambiente (n\u00e3o conter\u00e1 espa\u00e7os), seguida por um igual (sem espa\u00e7os antes ou depois), seguida pelo valor da vari\u00e1vel (que tamb\u00e9m n\u00e3o conter\u00e1 espa\u00e7os). Em ./inspercoin criar carteira <nome> o programa deve criar dois arquivos ( <nome>.private contendo a chave privada em uma string de 128 hexa e <nome>.public contendo uma chave de 64 hexa). Nota que as chaves p\u00fablicas \u00e9 que ir\u00e3o servir de endere\u00e7o de origem e destino nas transa\u00e7\u00f5es. Este c\u00f3digo est\u00e1 pronto, garanta que continua funcionando! Em ./inspercoin enviar <valor> da carteira <carteira> para endereco <chave_publica_destino> com recompensa <valor_recompensa> o programa l\u00ea a carteira, usa a chave privada para assinar a transa\u00e7\u00e3o e a chave p\u00fablica como origem do montante! Esta chamada est\u00e1 praticamente pronta, bastando alterar a URL da API para ser lida do arquivo de configura\u00e7\u00e3o. Importante: a vari\u00e1vel DEFAULT_WALLET ser\u00e1 utilizada apenas na pr\u00f3xima tag/vers\u00e3o! NOTA desta vers\u00e3o : 2.0","title":"Tag lab2.0.x: Vers\u00e3o Iniciante"},{"location":"labs/processos/#tag-lab21x-versao-em-desenvolvimento","text":"Todas as transa\u00e7\u00f5es sem origem (ex: sem uso do da carteira <endere\u00e7o> ) e de minera\u00e7\u00e3o sem destino devem ser feitas para a carteira padr\u00e3o definida na vari\u00e1vel de ambiente DEFAULT_WALLET da tag anterior (ou seja, ler os arquivos to_rico.private para assinar e to_rico.public para servir como endere\u00e7o de origem/destino). Al\u00e9m dos comandos da vers\u00e3o anterior, o programa pode ser chamado pela linha de comando, utilizando as seguintes sintaxes: ./inspercoin enviar <valor> para endereco <chave_publica_destino> com recompensa <valor_recompensa> ./inspercoin minear transacao na carteira <carteira> ./inspercoin minear transacao Requisitos: Em ./inspercoin enviar <valor> para endereco <chave_publica_destino> com recompensa <valor_recompensa> note que n\u00e3o foi informado uma carteira. Dever\u00e1 ser utilizada a indicada em DEFAULT_WALLET no config.ic . O mesmo vale para ./inspercoin minear transacao , onde o endere\u00e7o contido na chave p\u00fablica da carteira padr\u00e3o deve ser o endere\u00e7o da recompensa. Em ./inspercoin minear transacao na carteira <carteira> o programa minera uma transa\u00e7\u00e3o, formando um bloco. Caso o programa tente minerar uma transa\u00e7\u00e3o mas falhe (porque outro usu\u00e1rio j\u00e1 minerou e fez broadcast desta transa\u00e7\u00e3o primeiro), ent\u00e3o o programa apenas retorna mensagem adequada de que n\u00e3o foi poss\u00edvel fazer o broadcasting do bloco. Para minerar transa\u00e7\u00f5es, ser\u00e1 preciso corrigir a fun\u00e7\u00e3o miner_address , informando corretamente o endere\u00e7o de destino da recompensa. Al\u00e9m disso, ser\u00e1 preciso corrigir a fun\u00e7\u00e3o get_last_block_hash pois a mesma est\u00e1 retornando sempre zeros, mas ser\u00e1 necess\u00e1rio utilizar as rotas da API para buscar pelo hash do \u00faltimo bloco minerado! NOTA desta vers\u00e3o : 3.5","title":"Tag lab2.1.x: Vers\u00e3o Em Desenvolvimento"},{"location":"labs/processos/#tag-lab22x-versao-pleno-atingiu-objetivos-medios","text":"Al\u00e9m dos comandos da vers\u00e3o anterior, o programa pode ser chamado pela linha de comando, utilizando as seguintes sintaxes: ./inspercoin minear <qtde> transacoes Requisitos: Em ./inspercoin minear <qtde> transacoes o programa cria <qtde> processos que rodam concorrentemente tentando minerar blocos. O programa pai s\u00f3 encerra ap\u00f3s todos os filhos retornarem. Exiba mensagens contendo informa\u00e7\u00f5es sobre blocos minerados com sucesso! NOTA desta vers\u00e3o : 5.0","title":"Tag lab2.2.x: Vers\u00e3o Pleno - Atingiu objetivos m\u00e9dios"},{"location":"labs/processos/#tag-lab23x-versao-senior-atingiu-objetivos-avancados","text":"Al\u00e9m dos comandos da vers\u00e3o anterior, o programa pode ser chamado pela linha de comando, utilizando as seguintes sintaxes: ./inspercoin minear <qtde_tran> transacoes em <qtde_proc> processos Requisitos: O programa faz requisi\u00e7\u00f5es \u00e0 API e mant\u00e9m em execu\u00e7\u00e3o <qtde_proc> processos rodando concorrentemente minerando transa\u00e7\u00f5es. Se a minera\u00e7\u00e3o de algum bloco falhar porque o bloco foi minerado primeiro por outra pessoa na rede, apenas ignore (n\u00e3o precisa subir nova execu\u00e7\u00e3o). Caso fa\u00e7a uma chamada \u00e0 API e n\u00e3o consiga transa\u00e7\u00f5es suficientes para iniciar pelo menos processos, ignore e suba apenas o que conseguir! Observe que at\u00e9 aqui a API de GET transa\u00e7\u00f5es dever\u00e1 ser chamada apenas uma vez. NOTA desta vers\u00e3o : 8.0","title":"Tag lab2.3.x: Vers\u00e3o S\u00eanior - Atingiu objetivos avan\u00e7ados"},{"location":"labs/processos/#tag-lab24x-versao-especialista-demonstra-conhecimentos-que-superam-expectativas","text":"Al\u00e9m dos comandos da vers\u00e3o anterior, o programa pode ser chamado pela linha de comando, utilizando as seguintes sintaxes: ./inspercoin minear em <qtde_proc> processos ./inspercoin minear em <qtde_proc> processos na carteira <carteira> Requisitos: O programa realiza requisi\u00e7\u00f5es de transa\u00e7\u00f5es e mant\u00e9m <qtde_proc> processos rodando concorrentemente tentando minerar transa\u00e7\u00f5es. Aqui, para cada filho que retornar, um novo filho \u00e9 criado para minerar uma transa\u00e7\u00e3o diferente. Caso n\u00e3o existam transa\u00e7\u00f5es, o pai deve tentar subir novamente um filho em 5 segundos (buscar por nova transa\u00e7\u00e3o, iniciando a minera\u00e7\u00e3o no filho, caso exista transa\u00e7\u00e3o esperando minera\u00e7\u00e3o). A ideia \u00e9 manter ` processos rodando sempre que poss\u00edvel. Observe que a API de GET transa\u00e7\u00f5es precisar\u00e1 ser chamada m\u00faltiplas vezes. Ao receber CTRL+C, o programa pai encerra todos os filhos e sai com sinal adequado. Ao sair, apenas o programa pai deve exibir a mensagem na sa\u00edda padr\u00e3o Encerrando minera\u00e7\u00e3o!\\n . NOTA desta vers\u00e3o : 10.0","title":"Tag lab2.4.x: Vers\u00e3o Especialista - Demonstra conhecimentos que Superam Expectativas"},{"location":"labs/processos/#prazo","text":"Clique Aqui","title":"Prazo"},{"location":"labs/processos/#referencias","text":"Parte do texto foi escrito utilizando https://chatbot.theb.ai/","title":"Refer\u00eancias"},{"location":"labs/threads/","text":"Sort-Merge \u00b6 Introdu\u00e7\u00e3o \u00b6 No Laborat\u00f3rio de Threads, iremos implementar um algoritmo de ordena\u00e7\u00e3o de grandes volumes de dados utilizando Threads para obter um alto desempenho. O algoritmo, chamado Sort-Merge (ordena\u00e7\u00e3o-jun\u00e7\u00e3o), \u00e9 utilizado para ordenar dados em situa\u00e7\u00f5es nas quais n\u00e3o \u00e9 poss\u00edvel carregar todos os dados na mem\u00f3ria do computador. No caso dos algoritmos de ordena\u00e7\u00e3o tradicionais, como InsertionSort ou BubbleSort, os dados s\u00e3o carregados na mem\u00f3ria da m\u00e1quina e ordenados. O algoritmo Sort-Merge possui duas fases distintas, com cada fase consistindo em v\u00e1rios passos. Na primeira fase, chamada fase de Sort (ordena\u00e7\u00e3o), os dados s\u00e3o divididos em partes que caibam na mem\u00f3ria dispon\u00edvel, e s\u00e3o ent\u00e3o ordenados e armazenados em arquivos tempor\u00e1rios. Essa fase resulta na cria\u00e7\u00e3o de um conjunto de arquivos tempor\u00e1rios, cada um contendo partes (regi\u00f5es) do arquivo original ordenados. A Figura 1 abaixo ilustra a fase de Sort . Na segunda fase, denominada fase de Merge (jun\u00e7\u00e3o), pares de arquivos tempor\u00e1rios criados na fase anterior s\u00e3o lidos dos arquivos tempor\u00f3rios e ordenados, intercalando em ordem crescente os elementos lidos, de modo a resultar em um novo conjunto de arquivos tempor\u00e1rios ordenados. Os itens de dois arquivos da etapa anterior s\u00e3o intercalados at\u00e9 que se obtenha um arquivo com todos os dados ordenados. A figura 2 abaixo ilustra a fase de Merge O que precisa ser feito \u00b6 Sua tarefa \u00e9 criar um programa que implemente o algoritmo Sort-Merge utilizando threads. Ser\u00e3o disponibilizados dois programas ( sort.o e sort-merge.o ) j\u00e1 compilados que auxiliar\u00e3o no desenvolvimento da sua solu\u00e7\u00e3o. O programa sort.o contem a implementa\u00e7\u00e3o da cria\u00e7\u00e3o das threads para fase de Sort , veja a seguir. #include <stdlib.h> #include <pthread.h> #include <stdio.h> #include <unistd.h> #include <string.h> #include \"sort-merge.h\" void * sort(void *args); int main(int nArgs, char **argv) { int nThreads, nItens; FILE *fp; if(nArgs != 4) return -1; nThreads = atoi(argv[1]); nItens = atoi(argv[2]); fp = fopen(argv[3],\"r\"); if( !fp ){ printf(\"Erro ao abrir arquivo: %s\\n\",argv[3]); return -1; } printf(\"Serao criadas %d threads.\\n\",nThreads); fflush(stdout); pthread_t *tids = malloc(nThreads * sizeof(pthread_t)); struct sort_args *vet_sort = malloc(nThreads * sizeof(struct sort_args)); pthread_mutex_t mutex_file = PTHREAD_MUTEX_INITIALIZER; for (int i = 0; i < nThreads; i++) { vet_sort[i].idxThread = i; vet_sort[i].nThreads = nThreads; vet_sort[i].lineFiles = nItens; vet_sort[i].mutex_file = &mutex_file; vet_sort[i].fp = fp; pthread_create(&tids[i], NULL, sort, &vet_sort[i]); printf(\"Criou thread:%d fase sort\\n\", i); } printf(\"Funcao main() espera as threads sort finalizarem...\\n\"); fflush(stdout); FILE **fpOut = malloc(nThreads*sizeof(FILE)); for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], (void**)&fpOut[i]); fclose(fpOut[i]); } fclose(fp); free(vet_sort); free(tids); free(fpOut); printf(\"Funcao main() finalizando normalmente...\\n\"); return 0; } Voc\u00ea precisar\u00e1 implementar a fun\u00e7\u00e3o void * sort(void * args) que representa a thread respons\u00e1vel em ler concorrentemente o arquivo de entrada no arquivo solucao.c , esse arquivo conter\u00e1 as solu\u00e7\u00f5es das fase de Sort e fase de Sort-Merge . Para compilar a sua solu\u00e7\u00e3o use o comando: $ gcc -g -Og -Wall sort.o solucao.c -o sort -pthread Para executar o programa e testar sua solu\u00e7\u00e3o, informe por linha de comando o n\u00famero de threads ( nThreads ) que o programa dever\u00e1 criar e o quantidade de itens ( nItens ) no arquivo que ser\u00e1 ordenado e o nome do arquivo, por exemplo: ./sort nThreads nItens arqIn ./sort 4 16 in01.txt Considere que quantidade de itens dividido pela quantidade de threads ter\u00e1 sempre um valor inteiro, ou seja, nItens % nThreads == 0 e, al\u00e9m disso considere que nItens e nThreads sempre ser\u00e3o pot\u00eancia de 2. O programa sort-merge.o contem a implementa\u00e7\u00e3o completa da cria\u00e7\u00e3o das threads para fase de Sort e para fase de Merge , e ap\u00f3s resolver a fase anterior voc\u00ea pode compilar esse programa junto com a sua solu\u00e7\u00e3o no arquivo solucao.c . #include <stdlib.h> #include <pthread.h> #include <stdio.h> #include <unistd.h> #include <string.h> #include \"sort-merge.h\" void * sort(void *args); void * merge(void *args); int main(int nArgs, char **argv) { int nThreads, nItens; FILE *fp; if(nArgs != 4) return -1; nThreads = atoi(argv[1]); nItens = atoi(argv[2]); fp = fopen(argv[3],\"r\"); if( !fp ){ printf(\"Erro ao abrir arquivo: %s\\n\",argv[3]); return -1; } printf(\"Serao criadas %d threads.\\n\",nThreads); fflush(stdout); pthread_t *tids = malloc(nThreads * sizeof(pthread_t)); struct sort_args *vet_sort = malloc(nThreads * sizeof(struct sort_args)); pthread_mutex_t mutex_file = PTHREAD_MUTEX_INITIALIZER; for (int i = 0; i < nThreads; i++) { vet_sort[i].idxThread = i; vet_sort[i].nThreads = nThreads; vet_sort[i].lineFiles = nItens; vet_sort[i].mutex_file = &mutex_file; vet_sort[i].fp = fp; pthread_create(&tids[i], NULL, sort, &vet_sort[i]); printf(\"Criou thread:%d fase sort\\n\", i); } printf(\"Funcao main() espera as threads sort finalizarem...\\n\"); fflush(stdout); FILE **fpOut = malloc(nThreads*sizeof(FILE)); for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], (void**)&fpOut[i]); } fclose(fp); free(vet_sort); free(tids); while( nThreads > 1){ nThreads = nThreads/2; tids = malloc(nThreads * sizeof(pthread_t)); struct merge_args *vet_merge = malloc(nThreads * sizeof(struct merge_args)); for (int i = 0; i < nThreads; i++) { vet_merge[i].idxThread = i; vet_merge[i].nThreads = nThreads; vet_merge[i].fp1 = fpOut[i*2]; vet_merge[i].fp2 = fpOut[(i*2)+1]; pthread_create(&tids[i], NULL, merge, &vet_merge[i]); printf(\"Criou thread:%d fase merge nThread:%d \\n\", i,nThreads); } for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], (void**)&fpOut[i]); } free(tids); free(vet_merge); } fclose(fpOut[0]); free(fpOut); printf(\"Funcao main() finalizando normalmente...\\n\"); return 0; } Para compilar a sua solu\u00e7\u00e3o ( solucao.c ) com o programa sort-merge.o use o comando: $ gcc -g -Og -Wall sort-merge.o solucao.c -o sort-merge -pthread Como come\u00e7ar? \u00b6 Fa\u00e7a git pull no seu reposit\u00f3rio de atividades e verifique na pasta lab se voc\u00ea recebeu os seguintes arquivos: - sort.o contem o c\u00f3digo bin\u00e1rio que cria as threads na fase de Sort . - sort-merge.o contem o c\u00f3digo bin\u00e1rio que cria as threads na fase de Sort e fase de Merge . - sort-merge.h arquivo com a declara\u00e7\u00e3o das estrutas e as fun\u00e7\u00f5es usadas nas duas fases. - in01.txt arquivo de teste para voc\u00ea come\u00e7ar a implementar as suas solu\u00e7\u00f5es. - solucao.c programa fonte que dever\u00e1 ser entrega com a sua implementa\u00e7\u00e3o das threads nas fases Sort e Merge . Avalia\u00e7\u00e3o \u00b6 O programa ser\u00e1 avaliado usando uma rubrica que descreve as duas fases implementadas. Aten\u00e7\u00e3o: Os testes autom\u00e1ticos ser\u00e3o nossa forma principal de avalia\u00e7\u00e3o. Entretanto, o professor poder\u00e1 utilizar processos extras de avalia\u00e7\u00e3o, como: entrevistas, revis\u00e3o manual de c\u00f3digo. Como entregar as fases implementadas \u00b6 Entregue cada vers\u00e3o utilizando o padr\u00e3o j\u00e1 conhecido. Exemplo da vers\u00e3o lab3.0.x : IMPORTANTE : Os arquivos fontes disponilizados s\u00e3o para voc\u00eas entenderem como s\u00e3o realizadas as chamadas das threads, n\u00e3o gere novamente os arquivos sort.o e sort-merge.o . $ git tag -a lab3.0.55 -m \"lab3.0.55\" $ git push origin lab3.0.55 Tag lab3.0.x : fase Sort \u00b6 Na fase de Sort cada thread dever\u00e1 alocar um espa\u00e7ao na mem\u00f3ria para armazenar os itens de sua regi\u00e3o, para tanto considere as seguintes observa\u00e7\u00f5es: No arquivo de entrada cada item no arquivo de entrada ser\u00e1 uma sequ\u00eancia de caracteres (por exemplo um nome de um animal), considere que os itens ter\u00e3o no m\u00e1ximo 20 caracteres (mas podem ter somente um caracteres) e cada um deles estar\u00e1 armazenado em uma linha do arquivo, al\u00e9m disso podemos ter itens repetidos no arquivo. O arquivo de entrada ser\u00e1 um recurso compartilhado que precisar\u00e1 tem seu acesso controlado, de forma que cada thread acesse o arquivo uma por vez. Al\u00e9m disso voc\u00ea tamb\u00e9m deve resolver como fazer com que a thread fa\u00e7a a leitura correta de sua regi\u00e3o no arquivo de entrada. Ser\u00e3o criadas nThreads (Thread 0, 1, ... n), informado por linha de linha de comando, e cada thread deve ler sua regi\u00e3o no arquivo de entrada corretamente, ou seja, conforme exemplo da figura 1. Nessa fase voc\u00ea cada thread pode utilizar algoritmos tradicionais de ordena\u00e7\u00e3o (InsertionSort ou BubbleSort), para ordem ordenar sua por\u00e7\u00e3o do arquivo em mem\u00f3ria. Nessa fase voc\u00ea cada thread pode utilizar algoritmos tradicionais de ordena\u00e7\u00e3o (InsertionSort ou BubbleSort), para ordem ordenar sua por\u00e7\u00e3o do arquivo em mem\u00f3ria. Ao final da ordena\u00e7\u00e3o a thread deve escrever o seu resultado em um arquivo, a Thread 0 cria e escreve no arquivo 0.txt , a Thread 1 cria e escreve no arquivo 1.txt e assim por dianto. E por fim retorna para fun\u00e7\u00e3o principal ( main() ) o ponteiro ( FILE * ) do arquivo que foi criado para armazenar os seus itens ordenados. NOTA desta fase : 6.0 Tag lab3.1.x : fase Sort-Merge \u00b6 para realizar essa fase voc\u00ea dever\u00e1 ter finalizado a fase de Sort , pois esta fase tem como entrada os arquivos gerados na fase anterior (veja Figura 2). Por conta disso considere as seguintes observa\u00e7\u00f5es: As threads nessa fase ter\u00e3o como entrada os ponteiros dos arquivos gerados na fase anterior. No programa sort-merge.o poder\u00e1 ver que os arquivos s\u00e3o passadas para as threads atrav\u00e9s de uma estrutura ( struct ). Cada thread receber\u00e1 dois ponteiro de arquivos da fase anterior e far\u00e1 o merge (intercala\u00e7\u00e3o) dos dois arquivos e gerando um terceiro arquivo que ser\u00e1 retornado para a fun\u00e7\u00e3o principal ( main() ), que usar\u00e1 esse arquivo para pr\u00f3xima itera\u00e7\u00e3o. O nome do arquivo criado nessa fase dever\u00e1 ter o seguinte formato = quantidade de threads que est\u00e3o executanto simultanamente concatenado com o n\u00famero da thread (veja a Figura 2). Por exemplo se tiverem 2 threads executando simultaneamente a Thread 0 gerar\u00e1 o arquivo 20.txt e a Thread 1 gerar\u00e1 o arquivo 21.txt Note na fun\u00e7\u00e3o ( main() ) que a cada itera\u00e7\u00e3o o n\u00famero de threads ser\u00e1 reduzida pela metada, at\u00e9 que reste somente uma thread e assim \u00e9 finalizada o merge. NOTA desta vers\u00e3o : 10.0 Prazo \u00b6 Clique Aqui","title":"Sort-Merge"},{"location":"labs/threads/#sort-merge","text":"","title":"Sort-Merge"},{"location":"labs/threads/#introducao","text":"No Laborat\u00f3rio de Threads, iremos implementar um algoritmo de ordena\u00e7\u00e3o de grandes volumes de dados utilizando Threads para obter um alto desempenho. O algoritmo, chamado Sort-Merge (ordena\u00e7\u00e3o-jun\u00e7\u00e3o), \u00e9 utilizado para ordenar dados em situa\u00e7\u00f5es nas quais n\u00e3o \u00e9 poss\u00edvel carregar todos os dados na mem\u00f3ria do computador. No caso dos algoritmos de ordena\u00e7\u00e3o tradicionais, como InsertionSort ou BubbleSort, os dados s\u00e3o carregados na mem\u00f3ria da m\u00e1quina e ordenados. O algoritmo Sort-Merge possui duas fases distintas, com cada fase consistindo em v\u00e1rios passos. Na primeira fase, chamada fase de Sort (ordena\u00e7\u00e3o), os dados s\u00e3o divididos em partes que caibam na mem\u00f3ria dispon\u00edvel, e s\u00e3o ent\u00e3o ordenados e armazenados em arquivos tempor\u00e1rios. Essa fase resulta na cria\u00e7\u00e3o de um conjunto de arquivos tempor\u00e1rios, cada um contendo partes (regi\u00f5es) do arquivo original ordenados. A Figura 1 abaixo ilustra a fase de Sort . Na segunda fase, denominada fase de Merge (jun\u00e7\u00e3o), pares de arquivos tempor\u00e1rios criados na fase anterior s\u00e3o lidos dos arquivos tempor\u00f3rios e ordenados, intercalando em ordem crescente os elementos lidos, de modo a resultar em um novo conjunto de arquivos tempor\u00e1rios ordenados. Os itens de dois arquivos da etapa anterior s\u00e3o intercalados at\u00e9 que se obtenha um arquivo com todos os dados ordenados. A figura 2 abaixo ilustra a fase de Merge","title":"Introdu\u00e7\u00e3o"},{"location":"labs/threads/#o-que-precisa-ser-feito","text":"Sua tarefa \u00e9 criar um programa que implemente o algoritmo Sort-Merge utilizando threads. Ser\u00e3o disponibilizados dois programas ( sort.o e sort-merge.o ) j\u00e1 compilados que auxiliar\u00e3o no desenvolvimento da sua solu\u00e7\u00e3o. O programa sort.o contem a implementa\u00e7\u00e3o da cria\u00e7\u00e3o das threads para fase de Sort , veja a seguir. #include <stdlib.h> #include <pthread.h> #include <stdio.h> #include <unistd.h> #include <string.h> #include \"sort-merge.h\" void * sort(void *args); int main(int nArgs, char **argv) { int nThreads, nItens; FILE *fp; if(nArgs != 4) return -1; nThreads = atoi(argv[1]); nItens = atoi(argv[2]); fp = fopen(argv[3],\"r\"); if( !fp ){ printf(\"Erro ao abrir arquivo: %s\\n\",argv[3]); return -1; } printf(\"Serao criadas %d threads.\\n\",nThreads); fflush(stdout); pthread_t *tids = malloc(nThreads * sizeof(pthread_t)); struct sort_args *vet_sort = malloc(nThreads * sizeof(struct sort_args)); pthread_mutex_t mutex_file = PTHREAD_MUTEX_INITIALIZER; for (int i = 0; i < nThreads; i++) { vet_sort[i].idxThread = i; vet_sort[i].nThreads = nThreads; vet_sort[i].lineFiles = nItens; vet_sort[i].mutex_file = &mutex_file; vet_sort[i].fp = fp; pthread_create(&tids[i], NULL, sort, &vet_sort[i]); printf(\"Criou thread:%d fase sort\\n\", i); } printf(\"Funcao main() espera as threads sort finalizarem...\\n\"); fflush(stdout); FILE **fpOut = malloc(nThreads*sizeof(FILE)); for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], (void**)&fpOut[i]); fclose(fpOut[i]); } fclose(fp); free(vet_sort); free(tids); free(fpOut); printf(\"Funcao main() finalizando normalmente...\\n\"); return 0; } Voc\u00ea precisar\u00e1 implementar a fun\u00e7\u00e3o void * sort(void * args) que representa a thread respons\u00e1vel em ler concorrentemente o arquivo de entrada no arquivo solucao.c , esse arquivo conter\u00e1 as solu\u00e7\u00f5es das fase de Sort e fase de Sort-Merge . Para compilar a sua solu\u00e7\u00e3o use o comando: $ gcc -g -Og -Wall sort.o solucao.c -o sort -pthread Para executar o programa e testar sua solu\u00e7\u00e3o, informe por linha de comando o n\u00famero de threads ( nThreads ) que o programa dever\u00e1 criar e o quantidade de itens ( nItens ) no arquivo que ser\u00e1 ordenado e o nome do arquivo, por exemplo: ./sort nThreads nItens arqIn ./sort 4 16 in01.txt Considere que quantidade de itens dividido pela quantidade de threads ter\u00e1 sempre um valor inteiro, ou seja, nItens % nThreads == 0 e, al\u00e9m disso considere que nItens e nThreads sempre ser\u00e3o pot\u00eancia de 2. O programa sort-merge.o contem a implementa\u00e7\u00e3o completa da cria\u00e7\u00e3o das threads para fase de Sort e para fase de Merge , e ap\u00f3s resolver a fase anterior voc\u00ea pode compilar esse programa junto com a sua solu\u00e7\u00e3o no arquivo solucao.c . #include <stdlib.h> #include <pthread.h> #include <stdio.h> #include <unistd.h> #include <string.h> #include \"sort-merge.h\" void * sort(void *args); void * merge(void *args); int main(int nArgs, char **argv) { int nThreads, nItens; FILE *fp; if(nArgs != 4) return -1; nThreads = atoi(argv[1]); nItens = atoi(argv[2]); fp = fopen(argv[3],\"r\"); if( !fp ){ printf(\"Erro ao abrir arquivo: %s\\n\",argv[3]); return -1; } printf(\"Serao criadas %d threads.\\n\",nThreads); fflush(stdout); pthread_t *tids = malloc(nThreads * sizeof(pthread_t)); struct sort_args *vet_sort = malloc(nThreads * sizeof(struct sort_args)); pthread_mutex_t mutex_file = PTHREAD_MUTEX_INITIALIZER; for (int i = 0; i < nThreads; i++) { vet_sort[i].idxThread = i; vet_sort[i].nThreads = nThreads; vet_sort[i].lineFiles = nItens; vet_sort[i].mutex_file = &mutex_file; vet_sort[i].fp = fp; pthread_create(&tids[i], NULL, sort, &vet_sort[i]); printf(\"Criou thread:%d fase sort\\n\", i); } printf(\"Funcao main() espera as threads sort finalizarem...\\n\"); fflush(stdout); FILE **fpOut = malloc(nThreads*sizeof(FILE)); for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], (void**)&fpOut[i]); } fclose(fp); free(vet_sort); free(tids); while( nThreads > 1){ nThreads = nThreads/2; tids = malloc(nThreads * sizeof(pthread_t)); struct merge_args *vet_merge = malloc(nThreads * sizeof(struct merge_args)); for (int i = 0; i < nThreads; i++) { vet_merge[i].idxThread = i; vet_merge[i].nThreads = nThreads; vet_merge[i].fp1 = fpOut[i*2]; vet_merge[i].fp2 = fpOut[(i*2)+1]; pthread_create(&tids[i], NULL, merge, &vet_merge[i]); printf(\"Criou thread:%d fase merge nThread:%d \\n\", i,nThreads); } for (int i = 0; i < nThreads; i++) { pthread_join(tids[i], (void**)&fpOut[i]); } free(tids); free(vet_merge); } fclose(fpOut[0]); free(fpOut); printf(\"Funcao main() finalizando normalmente...\\n\"); return 0; } Para compilar a sua solu\u00e7\u00e3o ( solucao.c ) com o programa sort-merge.o use o comando: $ gcc -g -Og -Wall sort-merge.o solucao.c -o sort-merge -pthread","title":"O que precisa ser feito"},{"location":"labs/threads/#como-comecar","text":"Fa\u00e7a git pull no seu reposit\u00f3rio de atividades e verifique na pasta lab se voc\u00ea recebeu os seguintes arquivos: - sort.o contem o c\u00f3digo bin\u00e1rio que cria as threads na fase de Sort . - sort-merge.o contem o c\u00f3digo bin\u00e1rio que cria as threads na fase de Sort e fase de Merge . - sort-merge.h arquivo com a declara\u00e7\u00e3o das estrutas e as fun\u00e7\u00f5es usadas nas duas fases. - in01.txt arquivo de teste para voc\u00ea come\u00e7ar a implementar as suas solu\u00e7\u00f5es. - solucao.c programa fonte que dever\u00e1 ser entrega com a sua implementa\u00e7\u00e3o das threads nas fases Sort e Merge .","title":"Como come\u00e7ar?"},{"location":"labs/threads/#avaliacao","text":"O programa ser\u00e1 avaliado usando uma rubrica que descreve as duas fases implementadas. Aten\u00e7\u00e3o: Os testes autom\u00e1ticos ser\u00e3o nossa forma principal de avalia\u00e7\u00e3o. Entretanto, o professor poder\u00e1 utilizar processos extras de avalia\u00e7\u00e3o, como: entrevistas, revis\u00e3o manual de c\u00f3digo.","title":"Avalia\u00e7\u00e3o"},{"location":"labs/threads/#como-entregar-as-fases-implementadas","text":"Entregue cada vers\u00e3o utilizando o padr\u00e3o j\u00e1 conhecido. Exemplo da vers\u00e3o lab3.0.x : IMPORTANTE : Os arquivos fontes disponilizados s\u00e3o para voc\u00eas entenderem como s\u00e3o realizadas as chamadas das threads, n\u00e3o gere novamente os arquivos sort.o e sort-merge.o . $ git tag -a lab3.0.55 -m \"lab3.0.55\" $ git push origin lab3.0.55","title":"Como entregar as fases implementadas"},{"location":"labs/threads/#tag-lab30x-fase-sort","text":"Na fase de Sort cada thread dever\u00e1 alocar um espa\u00e7ao na mem\u00f3ria para armazenar os itens de sua regi\u00e3o, para tanto considere as seguintes observa\u00e7\u00f5es: No arquivo de entrada cada item no arquivo de entrada ser\u00e1 uma sequ\u00eancia de caracteres (por exemplo um nome de um animal), considere que os itens ter\u00e3o no m\u00e1ximo 20 caracteres (mas podem ter somente um caracteres) e cada um deles estar\u00e1 armazenado em uma linha do arquivo, al\u00e9m disso podemos ter itens repetidos no arquivo. O arquivo de entrada ser\u00e1 um recurso compartilhado que precisar\u00e1 tem seu acesso controlado, de forma que cada thread acesse o arquivo uma por vez. Al\u00e9m disso voc\u00ea tamb\u00e9m deve resolver como fazer com que a thread fa\u00e7a a leitura correta de sua regi\u00e3o no arquivo de entrada. Ser\u00e3o criadas nThreads (Thread 0, 1, ... n), informado por linha de linha de comando, e cada thread deve ler sua regi\u00e3o no arquivo de entrada corretamente, ou seja, conforme exemplo da figura 1. Nessa fase voc\u00ea cada thread pode utilizar algoritmos tradicionais de ordena\u00e7\u00e3o (InsertionSort ou BubbleSort), para ordem ordenar sua por\u00e7\u00e3o do arquivo em mem\u00f3ria. Nessa fase voc\u00ea cada thread pode utilizar algoritmos tradicionais de ordena\u00e7\u00e3o (InsertionSort ou BubbleSort), para ordem ordenar sua por\u00e7\u00e3o do arquivo em mem\u00f3ria. Ao final da ordena\u00e7\u00e3o a thread deve escrever o seu resultado em um arquivo, a Thread 0 cria e escreve no arquivo 0.txt , a Thread 1 cria e escreve no arquivo 1.txt e assim por dianto. E por fim retorna para fun\u00e7\u00e3o principal ( main() ) o ponteiro ( FILE * ) do arquivo que foi criado para armazenar os seus itens ordenados. NOTA desta fase : 6.0","title":"Tag lab3.0.x: fase Sort"},{"location":"labs/threads/#tag-lab31x-fase-sort-merge","text":"para realizar essa fase voc\u00ea dever\u00e1 ter finalizado a fase de Sort , pois esta fase tem como entrada os arquivos gerados na fase anterior (veja Figura 2). Por conta disso considere as seguintes observa\u00e7\u00f5es: As threads nessa fase ter\u00e3o como entrada os ponteiros dos arquivos gerados na fase anterior. No programa sort-merge.o poder\u00e1 ver que os arquivos s\u00e3o passadas para as threads atrav\u00e9s de uma estrutura ( struct ). Cada thread receber\u00e1 dois ponteiro de arquivos da fase anterior e far\u00e1 o merge (intercala\u00e7\u00e3o) dos dois arquivos e gerando um terceiro arquivo que ser\u00e1 retornado para a fun\u00e7\u00e3o principal ( main() ), que usar\u00e1 esse arquivo para pr\u00f3xima itera\u00e7\u00e3o. O nome do arquivo criado nessa fase dever\u00e1 ter o seguinte formato = quantidade de threads que est\u00e3o executanto simultanamente concatenado com o n\u00famero da thread (veja a Figura 2). Por exemplo se tiverem 2 threads executando simultaneamente a Thread 0 gerar\u00e1 o arquivo 20.txt e a Thread 1 gerar\u00e1 o arquivo 21.txt Note na fun\u00e7\u00e3o ( main() ) que a cada itera\u00e7\u00e3o o n\u00famero de threads ser\u00e1 reduzida pela metada, at\u00e9 que reste somente uma thread e assim \u00e9 finalizada o merge. NOTA desta vers\u00e3o : 10.0","title":"Tag lab3.1.x: fase Sort-Merge"},{"location":"labs/threads/#prazo","text":"Clique Aqui","title":"Prazo"},{"location":"outros/github/","text":"Github Password \u00b6 Caso o seu Github esteja solicitando senha a cada push, voc\u00ea tem duas op\u00e7\u00f5es para configurar um esquema de login autom\u00e1tico: chave ssh ou token . Chave SSH \u00b6 Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando ssh , acesse este LINK e veja como criar uma chave no Ubuntu e adicionar no Github. Ap\u00f3s esta configura\u00e7\u00e3o, acessos utilizando esta chave ser\u00e3o automaticamente reconhecidos e aceitos como do seu usu\u00e1rio. Arquivo .netrc \u00b6 Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando https , acesse este LINK e crie um Token . Na cria\u00e7\u00e3o do Token, selecione uma validade adequada (pelo menos 90 dias) e marque em Select scopes pelo menos a se\u00e7\u00e3o repo . Em seguida, crie um arquivo .netrc (sim, come\u00e7a com \"ponto\") na raiz do seu usu\u00e1rio no Ubuntu. O conte\u00fado deste arquivo deve estar no padr\u00e3o: machine github.com login bruna2022 password ghp_123412341234123412341234123412341234 Example Substitua bruna2022 pelo seu usu\u00e1rio do Github e ghp_1234* pelo Token criado. No terminal, configure as permiss\u00f5es adequadas para o arquivo: $ chmod 600 ~/.netrc E feito! Clique aqui para mais informa\u00e7\u00f5es","title":"Github Password"},{"location":"outros/github/#github-password","text":"Caso o seu Github esteja solicitando senha a cada push, voc\u00ea tem duas op\u00e7\u00f5es para configurar um esquema de login autom\u00e1tico: chave ssh ou token .","title":"Github Password"},{"location":"outros/github/#chave-ssh","text":"Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando ssh , acesse este LINK e veja como criar uma chave no Ubuntu e adicionar no Github. Ap\u00f3s esta configura\u00e7\u00e3o, acessos utilizando esta chave ser\u00e3o automaticamente reconhecidos e aceitos como do seu usu\u00e1rio.","title":"Chave SSH"},{"location":"outros/github/#arquivo-netrc","text":"Se voc\u00ea costuma clonar os reposit\u00f3rios utilizando https , acesse este LINK e crie um Token . Na cria\u00e7\u00e3o do Token, selecione uma validade adequada (pelo menos 90 dias) e marque em Select scopes pelo menos a se\u00e7\u00e3o repo . Em seguida, crie um arquivo .netrc (sim, come\u00e7a com \"ponto\") na raiz do seu usu\u00e1rio no Ubuntu. O conte\u00fado deste arquivo deve estar no padr\u00e3o: machine github.com login bruna2022 password ghp_123412341234123412341234123412341234 Example Substitua bruna2022 pelo seu usu\u00e1rio do Github e ghp_1234* pelo Token criado. No terminal, configure as permiss\u00f5es adequadas para o arquivo: $ chmod 600 ~/.netrc E feito! Clique aqui para mais informa\u00e7\u00f5es","title":"Arquivo .netrc"},{"location":"outros/vbox/","text":"Virtualbox \u00b6 Shared Folder \u00b6 Uma boa maneira de transferir arquivos entre a VM e a m\u00e1quina hospedeira (ambas as dire\u00e7\u00f5es) \u00e9 criar uma pasta compartilhada no Virtualbox. Acesse este LINK para mais informa\u00e7\u00f5es! Shared Clipboard \u00b6 Tamb\u00e9m \u00e9 poss\u00edvel fazer com que algo copiado (CTRL + C) no sistema principal possa ser colado no Ubuntu (CTRL + V na m\u00e1quina Virtual), e vice-versa! Procure no Google virtualbox enable shared clipboard .","title":"Virtualbox"},{"location":"outros/vbox/#virtualbox","text":"","title":"Virtualbox"},{"location":"outros/vbox/#shared-folder","text":"Uma boa maneira de transferir arquivos entre a VM e a m\u00e1quina hospedeira (ambas as dire\u00e7\u00f5es) \u00e9 criar uma pasta compartilhada no Virtualbox. Acesse este LINK para mais informa\u00e7\u00f5es!","title":"Shared Folder"},{"location":"outros/vbox/#shared-clipboard","text":"Tamb\u00e9m \u00e9 poss\u00edvel fazer com que algo copiado (CTRL + C) no sistema principal possa ser colado no Ubuntu (CTRL + V na m\u00e1quina Virtual), e vice-versa! Procure no Google virtualbox enable shared clipboard .","title":"Shared Clipboard"}]}